```python exec
from pcweb.pages.docs import custom_components
```

# Project Structure (Advanced)

## App Module

Reflex imports the main app module based on the `app_name` from the config, which **must define a module-level global named `app` as an instance of `rx.App`**.

The main app module is responsible for importing all other modules that make up the app and defining `app = rx.App()`.

**All other modules containing pages, state, and models MUST be imported by the main app module or package** for Reflex to include them in the compiled output.

# Breaking the App into Smaller Pieces

As applications scale, effective organization is crucial. This is achieved by breaking the application down into smaller, manageable modules and organizing them into logical packages that avoid circular dependencies.

In the following documentation there will be an app with an `app_name` of `example_big_app`. The main module would be `example_big_app/example_big_app.py`.

In the [Putting it all together](#putting-it-all-together) section there is a visual of the project folder structure to help follow along with the examples below.

### Pages Package: `example_big_app/pages`

All complex apps will have multiple pages, so it is recommended to create `example_big_app/pages` as a package.

1. This package should contain one module per page in the app.
2. If a particular page depends on the state, the substate should be defined in the same module as the page.
3. The page-returning function should be decorated with `rx.page()` to have it added as a route in the app.

```python
import reflex as rx

from ..state import AuthState


class LoginState(AuthState):
    @rx.event
    def handle_submit(self, form_data):
        self.logged_in = authenticate(form_data["username"], form_data["password"])


def login_field(name: str, **input_props):
    return rx.hstack(
        rx.text(name.capitalize()),
        rx.input(name=name, **input_props),
        width="100%",
        justify="between",
    )


@rx.page(route="/login")
def login():
    return rx.card(
        rx.form(
            rx.vstack(
                login_field("username"),
                login_field("password", type="password"),
                rx.button("Login"),
                width="100%",
                justify="center",
            ),
            on_submit=LoginState.handle_submit,
        ),
    )
```

### Templating: `example_big_app/template.py`

Most applications maintain a consistent layout and structure across pages. Defining this common structure in a separate module facilitates easy sharing and reuse when constructing individual pages.

**Best Practices**

1. Factor out common frontend UI elements into a function that returns a component.
2. If a function accepts a function that returns a component, it can be used as a decorator as seen below.

```python
from typing import Callable

import reflex as rx

from .components.menu import menu
from .components.navbar import navbar


def template(page: Callable[[], rx.Component]) -> rx.Component:
    return rx.vstack(
        navbar(),
        rx.hstack(
            menu(),
            rx.container(page()),
        ),
        width="100%",
    )
```

The `@template` decorator should appear below the `@rx.page` decorator and above the page-returning function. See the [Posts Page](#a-post-page-example_big_apppagespostspy) code for an example.

## State Management

Most pages will use State in some capacity. You should avoid adding vars to a
shared state that will only be used in a single page. Instead, define a new
subclass of `rx.State` and keep it in the same module as the page.

### Accessing other States

As of Reflex 0.4.3, any event handler can get access to an instance of any other
substate via the `get_state` API. From a practical perspective, this means that
state can be split up into smaller pieces without requiring a complex
inheritance hierarchy to share access to other states.

In previous releases, if an app wanted to store settings in `SettingsState` with
a page or component for modifying them, any other state with an event handler
that needed to access those settings would have to inherit from `SettingsState`,
even if the other state was mostly orthogonal. The other state would also now
always have to load the settings, even for event handlers that didn't need to
access them.

A better strategy is to load the desired state on demand from only the event
handler which needs access to the substate.

### A Settings Component: `example_big_app/components/settings.py`

```python
import reflex as rx


class SettingsState(rx.State):
    refresh_interval: int = 15
    auto_update: bool = True
    prefer_plain_text: bool = True
    posts_per_page: int = 20


def settings_dialog():
    return rx.dialog(...)
```

### A Post Page: `example_big_app/pages/posts.py`

This page loads the `SettingsState` to determine how many posts to display per page
and how often to refresh.

```python
import reflex as rx

from ..models import Post
from ..template import template
from ..components.settings import SettingsState


class PostsState(rx.State):
    refresh_tick: int
    page: int
    posts: list[Post]

    @rx.event
    async def on_load(self):
        settings = await self.get_state(SettingsState)
        if settings.auto_update:
            self.refresh_tick = settings.refresh_interval * 1000
        else:
            self.refresh_tick = 0

    @rx.event
    async def tick(self, _):
        settings = await self.get_state(SettingsState)
        with rx.session() as session:
            q = Post.select().offset(self.page * settings.posts_per_page).limit(settings.posts_per_page)
            self.posts = q.all()

    @rx.event
    def go_to_previous(self):
        if self.page > 0:
            self.page = self.page - 1

    @rx.event
    def go_to_next(self):
        if self.posts:
            self.page = self.page + 1


@rx.page(route="/posts", on_load=PostsState.on_load)
@template
def posts():
    return rx.vstack(
        rx.foreach(PostsState.posts, post_view),
        rx.hstack(
            rx.button("< Prev", on_click=PostsState.go_to_previous),
            rx.button("Next >", on_click=PostsState.go_to_next),
            justify="between",
        ),
        rx.moment(interval=PostsState.refresh_tick, on_change=PostsState.tick, display="none"),
        width="100%",
    )
```

### Common State: `example_big_app/state.py`

_Common_ states and substates that are shared by multiple pages or components
should be implemented in a separate module to avoid circular imports. This
module should not import other modules in the app.

## Component Reusability

The primary mechanism for reusing components in Reflex is to define a function that returns
the component, then simply call it where that functionality is needed.

Component functions typically should not take any State classes as arguments, but prefer
to import the needed state and access the vars on the class directly.

### Memoize Functions for Improved Performance

In a large app, if a component has many subcomponents or is used in a large number of places, it can improve compile and runtime performance to memoize the function with the `@lru_cache` decorator.

To memoize the `foo` component to avoid re-creating it many times simply add `@lru_cache` to the function definition, and the component will only be created once per unique set of arguments.

```python
from functools import lru_cache

import reflex as rx

class State(rx.State):
    v: str = "foo"


@lru_cache
def foo():
    return rx.text(State.v)


def index():
    return rx.flex(
        rx.button("Change", on_click=State.set_v(rx.cond(State.v != "bar", "bar", "foo"))),
        *[
            foo()
            for _ in range(100)
        ],
        direction="row",
        wrap="wrap",
    )
```

### example_big_app/components

This package contains reusable parts of the app, for example headers, footers,
and menus. If a particular component requires state, the substate may be defined
in the same module for locality. Any substate defined in a component module
should only contain fields and event handlers pertaining to that individual
component.

### External Components

Reflex 0.4.3 introduced support for the [`reflex component` CLI commands]({custom_components.overview.path}), which makes it easy
to bundle up common functionality to publish on PyPI as a standalone Python package
that can be installed and used in any Reflex app.

When wrapping npm components or other self-contained bits of functionality, it can be helpful
to move this complexity outside the app itself for easier maintenance and reuse in other apps.

## Database Models: `example_big_app/models.py`

It is recommended to implement all database models in a single file to make it easier to define relationships and understand the entire schema.

However, if the schema is very large, it might make sense to have a `models` package with individual models defined in their own modules.

At any rate, defining the models separately allows any page or component to import and use them without circular imports.

## Top-level Package: `example_big_app/__init__.py`

This is a great place to import all state, models, and pages that should be part of the app.
Typically, components and helpers do not need to imported, because they will be imported by
pages that use them (or they would be unused).

```python
from . import state, models
from .pages import index, login, post, product, profile, schedule

__all__ = [
    "state",
    "models",
    "index",
    "login",
    "post",
    "product",
    "profile",
    "schedule",
]
```

If any pages are not imported here, they will not be compiled as part of the app.

## example_big_app/example_big_app.py

This is the main app module. Since everything else is defined in other modules, this file becomes very simple.

```python
import reflex as rx

app = rx.App()
```

## File Management

There are two categories of non-code assets (media, fonts, stylesheets,
documents) typically used in a Reflex app.

### assets

The `assets` directory is used for **static** files that should be accessible
relative to the root of the frontend (default port 3000). When an app is deployed in
production mode, changes to the assets directory will NOT be available at runtime!

When referencing an asset, always use a leading forward slash, so the
asset can be resolved regardless of the page route where it may appear.

### uploaded_files

If an app needs to make files available dynamically at runtime, it is
recommended to set the target directory via `REFLEX_UPLOADED_FILES_DIR`
environment variable (default `./uploaded_files`), write files relative to the
path returned by `rx.get_upload_dir()`, and create working links via
`rx.get_upload_url(relative_path)`.

Uploaded files are served from the backend (default port 8000) via
`/_upload/<relative_path>`

## Putting it all together

Based on the previous discussion, the recommended project layout look like this.

```text
example-big-app/
├─ assets/
├─ example_big_app/
│  ├─ components/
│  │  ├─ __init__.py
│  │  ├─ auth.py
│  │  ├─ footer.py
│  │  ├─ menu.py
│  │  ├─ navbar.py
│  ├─ pages/
│  │  ├─ __init__.py
│  │  ├─ index.py
│  │  ├─ login.py
│  │  ├─ posts.py
│  │  ├─ product.py
│  │  ├─ profile.py
│  │  ├─ schedule.py
│  ├─ __init__.py
│  ├─ example_big_app.py
│  ├─ models.py
│  ├─ state.py
│  ├─ template.py
├─ uploaded_files/
├─ requirements.txt
├─ rxconfig.py
```

## Key Takeaways

- Like any other Python project, **split up the app into modules and packages** to keep the codebase organized and manageable.
- Using smaller modules and packages makes it easier to **reuse components and state** across the app
  without introducing circular dependencies.
- Create **individual functions** to encapsulate units of functionality and **reuse them** where needed.


```python exec
from pcweb.pages.docs import api_reference
```

# Configuration

Reflex apps can be configured using a configuration file, environment variables, and command line arguments.

## Configuration File

Running `reflex init` will create an `rxconfig.py` file in your root directory.
You can pass keyword arguments to the `Config` class to configure your app.

For example:

```python
# rxconfig.py
import reflex as rx

config = rx.Config(
    app_name="my_app_name",
    # Connect to your own database.
    db_url="postgresql://user:password@localhost:5432/my_db",
    # Change the frontend port.
    frontend_port=3001,
)
```

See the [config reference]({api_reference.config.path}) for all the parameters available.

## Environment Variables

You can override the configuration file by setting environment variables.
For example, to override the `frontend_port` setting, you can set the `FRONTEND_PORT` environment variable.

```bash
FRONTEND_PORT=3001 reflex run
```

## Command Line Arguments

Finally, you can override the configuration file and environment variables by passing command line arguments to `reflex run`.

```bash
reflex run --frontend-port 3001
```

See the [CLI reference]({api_reference.cli.path}) for all the arguments available.

## Customizable App Data Directory

The `REFLEX_DIR` environment variable can be set, which allows users to set the location where Reflex writes helper tools like Bun and NodeJS.

By default we use Platform specific directories:

On windows, `C:/Users/<username>/AppData/Local/reflex` is used.

On macOS, `~/Library/Application Support/reflex` is used.

On linux, `~/.local/share/reflex` is used.


```python exec
from pcweb import constants
from pcweb.pages.docs import wrapping_react, custom_components, styling, events
from pcweb.pages.docs.custom_components import custom_components as cc
```

# How Reflex Works

We'll use the following basic app that displays Github profile images as an example to explain the different parts of the architecture.

```python demo exec
import requests
import reflex as rx

class GithubState(rx.State):
    url: str = "https://github.com/reflex-dev"
    profile_image: str = "https://avatars.githubusercontent.com/u/104714959"

    @rx.event
    def set_profile(self, username: str):
        if username == "":
            return
        try:
            github_data = requests.get(f"https://api.github.com/users/{username}").json()
        except:
            return
        self.url = github_data["url"]
        self.profile_image = github_data["avatar_url"]

def index():
    return rx.hstack(
        rx.link(
            rx.avatar(src=GithubState.profile_image),
            href=GithubState.url,
        ),
        rx.input(
            placeholder="Your Github username",
            on_blur=GithubState.set_profile,
        ),
    )
```

## The Reflex Architecture

Full-stack web apps are made up of a frontend and a backend. The frontend is the user interface, and is served as a web page that runs on the user's browser. The backend handles the logic and state management (such as databases and APIs), and is run on a server.

In traditional web development, these are usually two separate apps, and are often written in different frameworks or languages. For example, you may combine a Flask backend with a React frontend. With this approach, you have to maintain two separate apps and end up writing a lot of boilerplate code to connect the frontend and backend.

We wanted to simplify this process in Reflex by defining both the frontend and backend in a single codebase, while using Python for everything. Developers should only worry about their app's logic and not about the low-level implementation details.

### TLDR

Under the hood, Reflex apps compile down to a [React](https://react.dev) frontend app and a [FastAPI](https://github.com/tiangolo/fastapi) backend app. Only the UI is compiled to Javascript; all the app logic and state management stays in Python and is run on the server. Reflex uses [WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) to send events from the frontend to the backend, and to send state updates from the backend to the frontend.

The diagram below provides a detailed overview of how a Reflex app works. We'll go through each part in more detail in the following sections.

```python exec
from reflex_image_zoom import image_zoom
```

```python eval
image_zoom(rx.image(src="/architecture.png"))
```

```python eval
rx.box(height="1em")
```

## Frontend

We wanted Reflex apps to look and feel like a traditional web app to the end user, while still being easy to build and maintain for the developer. To do this, we built on top of mature and popular web technologies.

When you `reflex run` your app, Reflex compiles the frontend down to a single-page [Next.js](https://nextjs.org) app and serves it on a port (by default `3000`) that you can access in your browser.

The frontend's job is to reflect the app's state, and send events to the backend when the user interacts with the UI. No actual logic is run on the frontend.

### Components

Reflex frontends are built using components that can be composed together to create complex UIs. Instead of using a templating language that mixes HTML and Python, we just use Python functions to define the UI.

```python
def index():
    return rx.hstack(
        rx.link(
            rx.avatar(src=GithubState.profile_image),
            href=GithubState.url,
        ),
        rx.input(
            placeholder="Your Github username",
            on_blur=GithubState.set_profile,
        ),
    )
```

In our example app, we have components such as `rx.hstack`, `rx.avatar`, and `rx.input`. These components can have different **props** that affect their appearance and functionality - for example the `rx.input` component has a `placeholder` prop to display the default text.

We can make our components respond to user interactions with events such as `on_blur`, which we will discuss more below.

Under the hood, these components compile down to React components. For example, the above code compiles down to the following React code:

```jsx
<HStack>
    <Link href=\{GithubState.url}>
        <Avatar src=\{GithubState.profile_image}/>
    </Link>
    <Input
        placeholder="Your Github username"
        // This would actually be a websocket call to the backend.
        onBlur=\{GithubState.set_profile}
    >
</HStack>
```

Many of our core components are based on [Radix](https://radix-ui.com/), a popular React component library. We also have many other components for graphing, datatables, and more.

We chose React because it is a popular library with a huge ecosystem. Our goal isn't to recreate the web ecosystem, but to make it accessible to Python developers.

This also lets our users bring their own components if we don't have a component they need. Users can [wrap their own React components]({wrapping_react.overview.path}) and then [publish them]({custom_components.overview.path}) for others to use. Over time we will build out our [third party component ecosystem]({cc.path}) so that users can easily find and use components that others have built.

### Styling

We wanted to make sure Reflex apps look good out of the box, while still giving developers full control over the appearance of their app.

We have a core [theming system]({styling.theming.path}) that lets you set high level styling options such as dark mode and accent color throughout your app to give it a unified look and feel.

Beyond this, Reflex components can be styled using the full power of CSS. We leverage the [Emotion](https://emotion.sh/docs/introduction) library to allow "CSS-in-Python" styling, so you can pass any CSS prop as a keyword argument to a component. This includes [responsive props]({styling.responsive.path}) by passing a list of values.

## Backend

Now let's look at how we added interactivity to our apps.

In Reflex only the frontend compiles to Javascript and runs on the user's browser, while all the state and logic stays in Python and is run on the server. When you `reflex run`, we start a FastAPI server (by default on port `8000`) that the frontend connects to through a websocket.

All the state and logic are defined within a `State` class.

```python
class GithubState(rx.State):
    url: str = "https://github.com/reflex-dev"
    profile_image: str = "https://avatars.githubusercontent.com/u/104714959"

    def set_profile(self, username: str):
        if username == "":
            return
        github_data = requests.get(f"https://api.github.com/users/\{username}").json()
        self.url = github_data["url"]
        self.profile_image = github_data["avatar_url"]
```

The state is made up of **vars** and **event handlers**.

Vars are any values in your app that can change over time. They are defined as class attributes on your `State` class, and may be any Python type that can be serialized to JSON. In our example, `url` and `profile_image` are vars.

Event handlers are methods in your `State` class that are called when the user interacts with the UI. They are the only way that we can modify the vars in Reflex, and can be called in response to user actions, such as clicking a button or typing in a text box. In our example, `set_profile` is an event handler that updates the `url` and `profile_image` vars.

Since event handlers are run on the backend, you can use any Python library within them. In our example, we use the `requests` library to make an API call to Github to get the user's profile image.

## Event Processing

Now we get into the interesting part - how we handle events and state updates.

Normally when writing web apps, you have to write a lot of boilerplate code to connect the frontend and backend. With Reflex, you don't have to worry about that - we handle the communication between the frontend and backend for you. Developers just have to write their event handler logic, and when the vars are updated the UI is automatically updated.

You can refer to the diagram above for a visual representation of the process. Let's walk through it with our Github profile image example.

### Event Triggers

The user can interact with the UI in many ways, such as clicking a button, typing in a text box, or hovering over an element. In Reflex, we call these **event triggers**.

```python
rx.input(
    placeholder="Your Github username",
    on_blur=GithubState.set_profile,
)
```

In our example we bind the `on_blur` event trigger to the `set_profile` event handler. This means that when the user types in the input field and then clicks away, the `set_profile` event handler is called.

### Event Queue

On the frontend, we maintain an event queue of all pending events. An event consists of three major pieces of data:

- **client token**: Each client (browser tab) has a unique token to identify it. This let's the backend know which state to update.
- **event handler**: The event handler to run on the state.
- **arguments**: The arguments to pass to the event handler.

Let's assume I type my username "picklelo" into the input. In this example, our event would look something like this:

```json
{
  "client_token": "abc123",
  "event_handler": "GithubState.set_profile",
  "arguments": ["picklelo"]
}
```

On the frontend, we maintain an event queue of all pending events.

When an event is triggered, it is added to the queue. We have a `processing` flag to make sure only one event is processed at a time. This ensures that the state is always consistent and there aren't any race conditions with two event handlers modifying the state at the same time.

```md alert info
# There are exceptions to this, such as [background events]({events.background_events.path}) which allow you to run events in the background without blocking the UI.
```

Once the event is ready to be processed, it is sent to the backend through a WebSocket connection.

### State Manager

Once the event is received, it is processed on the backend.

Reflex uses a **state manager** which maintains a mapping between client tokens and their state. By default, the state manager is just an in-memory dictionary, but it can be extended to use a database or cache. In production we use Redis as our state manager.

### Event Handling

Once we have the user's state, the next step is to run the event handler with the arguments.

```python
 def set_profile(self, username: str):
    if username == "":
        return
    github_data = requests.get(f"https://api.github.com/users/\{username}").json()
    self.url = github_data["url"]
    self.profile_image = github_data["avatar_url"]
```

In our example, the `set_profile` event handler is run on the user's state. This makes an API call to Github to get the user's profile image, and then updates the state's `url` and `profile_image` vars.

### State Updates

Every time an event handler returns (or [yields]({events.yield_events.path})), we save the state in the state manager and send the **state updates** to the frontend to update the UI.

To maintain performance as your state grows, internally Reflex keeps track of vars that were updated during the event handler (**dirty vars**). When the event handler is done processing, we find all the dirty vars and create a state update to send to the frontend.

In our case, the state update may look something like this:

```json
{
  "url": "https://github.com/picklelo",
  "profile_image": "https://avatars.githubusercontent.com/u/104714959"
}
```

We store the new state in our state manager, and then send the state update to the frontend. The frontend then updates the UI to reflect the new state. In our example, the new Github profile image is displayed.


# Integrations Shortcut

Reflex Build supports powerful integrations like databases, OpenAI, and Databricks, allowing you to connect external services to your app without complex setup. These integrations help you add advanced functionality—like AI-powered features, data analytics, or persistent storage—while speeding up development.

The **@** feature makes it easy to reference integrations directly while chatting with the AI Builder. By typing **@**, you can quickly insert integrations into your prompts without needing to configure them manually first.

```python exec
import reflex as rx
from reflex_image_zoom import image_zoom
```

```python eval
rx.el.div(
    image_zoom(
        rx.image(
            src=rx.color_mode_cond(
                "/ai_builder/features/shortcut_light.webp",
                "/ai_builder/features/shortcut_dark.webp",
            ),
            class_name="p-2 rounded-md h-auto",
            border=f"0.81px solid {rx.color('slate', 5)}",
        ),
        class_name="rounded-md overflow-hidden",
    ),
    class_name="w-full flex flex-col rounded-md cursor-pointer",
)
```

## How to Use

1. In the AI Builder chat, type **@**.
2. A **popover list** of available integrations will appear (e.g. Database, Databricks, OpenAI).
3. Select an integration from the list.
4. The integration will be inserted into your message as **@IntegrationName**.
5. Continue typing your request, and the AI Builder will use that integration context when generating.

## What It Does

- **Quick Access** – No need to remember integration names.
- **Context-Aware** – The AI Builder understands that `@Database` or `@OpenAI` refers to the actual integration.
- **Faster Building** – Jump directly into using integrations in your prompts.

## Common Use Cases

- **Query Data**
  "Show me the top 10 users from **@Database** ordered by signup date."

- **Generate with AI**
  "Use **@OpenAI** to summarize the user feedback table."


# Knowledge

The **Knowledge** feature lets you add context or rules that the AI Builder can reference when generating apps. This ensures your apps follow your guidelines, standards, or specific business logic.

```python exec
import reflex as rx
from reflex_image_zoom import image_zoom

def render_image():
    return rx.el.div(
        image_zoom(
            rx.image(
                src=rx.color_mode_cond(
                    "/ai_builder/features/knowledge_light.webp",
                    "/ai_builder/features/knowledge_dark.webp",
                ),
                class_name="p-2 rounded-md h-auto",
                border=f"0.81px solid {rx.color('slate', 5)}",
            ),
            class_name="rounded-md overflow-hidden",
        ),
        class_name="w-full flex flex-col rounded-md cursor-pointer",
    )
```

```python eval

rx.el.div(render_image())

```

## How to Add Knowledge

1. In the AI Builder workspace, go to the **Knowledge** section by clicking the **`@`** symbol in the bottom-left corner inside the chat area, and selecting the **Knowledge** tab. If you haven't submitted a prompt yet, you can click the **`@ Integrations`** button in the prompt area.
2. Enter your rule, guideline, or context description.
3. Save the entry. The AI Builder will automatically use it when generating apps.

## How It Works

- The AI Builder references your knowledge entries as rules or guidelines.
- Rules can define naming conventions, component usage, layout preferences, or other custom logic.
- Multiple rules can be added to cover different aspects of app generation.

## Common Use Cases

- **Maintain Consistency**
  Ensure all generated apps follow your company’s design or naming standards.

- **Enforce Business Logic**
  Guide the AI Builder to follow specific workflows, validations, or feature requirements.

- **Quickly Adapt AI Behavior**
  Add or update rules to influence new app generations without manual edits.


# Interaction Modes

Reflex Build gives you two ways to interact with the AI while creating your application: **Agent mode** and **Chat mode**.
You can switch between these modes from the dropdown at the bottom of the workspace.

```python exec
import reflex as rx
from reflex_image_zoom import image_zoom

def interaction_mode_image():
    return rx.el.div(
        image_zoom(
            rx.image(
                src=rx.color_mode_cond(
                    "/ai_builder/features/interaction_modes_light.webp",
                    "/ai_builder/features/interaction_modes_dark.webp",
                ),
                class_name="p-2 rounded-md h-auto",
                border=f"0.81px solid {rx.color('slate', 5)}",
            ),
            class_name="rounded-md overflow-hidden",
        ),
        class_name="w-full flex flex-col rounded-md cursor-pointer",
    )
```

```python eval

rx.el.div(interaction_mode_image())

```

## Agent Mode

In **Agent mode**, the AI acts as a proactive builder:

- **Plans ahead**: It breaks down your request into steps and explains its approach before making changes.
- **Applies changes directly**: Generates and edits files in your project automatically.
- **Optimized for workflows**: Best for building features, scaffolding components, or setting up integrations.

Use Agent mode when you want the AI to **take initiative** and help build out your app.


## Chat Mode

In **Chat mode**, the AI behaves more like a traditional conversational assistant:

- **Answers questions**: Provides explanations, references, and guidance without editing code.
- **Lightweight**: Great for quick clarifications, debugging help, or brainstorming ideas.
- **Safer experimentation**: No automatic file changes — you stay in full control.

Use Chat mode when you want to **ask questions** or get **advice without altering your codebase**.


## When to Use Each

- **Build a new feature or component** → Use **Agent**
- **Set up integrations (DB, etc.)** → Use **Agent**
- **Understand Reflex concepts** → Use **Chat**
- **Debug an error in your code** → Start with **Chat**, then switch to **Agent**
- **Explore ideas or best practices** → Use **Chat**


## Switching Modes

1. Look for the **mode selector** at the bottom of the workspace.
2. Choose **Agent** or **Chat** depending on your current task.
3. You can switch modes at any time without losing context.


## Best Practices

- **Start in Chat** to clarify your goal → **switch to Agent** to implement.
- Review the AI’s suggested changes before committing.
- If Agent output feels too heavy, fall back to Chat for lighter interaction.


# Secrets

The **Secrets** feature allows you to securely store environment-specific values that your app can use, such as API keys, tokens, or other sensitive information.


```python exec
import reflex as rx
from reflex_image_zoom import image_zoom

def render_image():
    return rx.el.div(
        image_zoom(
            rx.image(
                src=rx.color_mode_cond(
                    "/ai_builder/features/secrets_light.webp",
                    "/ai_builder/features/secrets_dark.webp",
                ),
                class_name="p-2 rounded-md h-auto",
                border=f"0.81px solid {rx.color('slate', 5)}",
            ),
            class_name="rounded-md overflow-hidden",
        ),
        class_name="w-full flex flex-col rounded-md cursor-pointer",
    )
```

```python eval

rx.el.div(render_image())

```

## Adding Secrets

### 1. Add Individually
- **Description:** Set a single secret by providing a key and value.
- **Example:**
  - Key: `OPENAI_API_KEY`
  - Value: `sk-xxxxxx`
- **Behavior:** The secret is encrypted and accessible to your app at runtime.

### 2. Add in Bulk (Raw Editor)
- **Description:** Upload multiple secrets at once using a simple `VAR=VALUE` format.
- **Example:**

```text
DATABASE_URL=postgresql://user:pass@host:5432/db
STRIPE_SECRET_KEY=sk_test_xxxxx
OPENAI_API_KEY=sk-xxxxxx
```

```python exec
import reflex as rx
from reflex_image_zoom import image_zoom
```

```python eval
rx.el.div(
    image_zoom(
        rx.image(
            src=rx.color_mode_cond(
                "/ai_builder/features/secret_bulk_light.webp",
                "/ai_builder/features/secret_bulk_dark.webp",
            ),
            class_name="p-2 rounded-md h-auto",
            border=f"0.81px solid {rx.color('slate', 5)}",
        ),
        class_name="rounded-md overflow-hidden",
    ),
    class_name="w-full flex flex-col rounded-md cursor-pointer",
)
```


- **Behavior:** Each secret is securely stored and immediately available in the app environment.


# Editor Modes

The AI Builder includes a powerful dual-mode editor that lets you view and edit your application code while tracking changes made by the AI. You can seamlessly switch between **Editor Mode** for manual code editing and **Diff Mode** for reviewing AI-generated changes.


```python exec
import reflex as rx
from reflex_image_zoom import image_zoom

def render_image():
    return rx.el.div(
        image_zoom(
            rx.image(
                src=rx.color_mode_cond(
                    "/ai_builder/features/diff_light.webp",
                    "/ai_builder/features/diff_dark.webp",
                ),
                class_name="p-2 rounded-md h-auto",
                border=f"0.81px solid {rx.color('slate', 5)}",
            ),
            class_name="rounded-md overflow-hidden",
        ),
        class_name="w-full flex flex-col rounded-md cursor-pointer",
    )
```

```python eval

rx.el.div(render_image())

```
## Modes: Editor vs Diff

### Editor Mode
The standard code editor where you can:
- **Write and modify code** directly in the interface
- **Navigate through files** using the file tree
- **Make manual changes** to your application
- **Save your modifications** which persist across sessions

### Diff Mode
A specialized view that highlights changes from the last AI prompt:
- **Green highlights** show code additions made by the AI
- **Red highlights** show code deletions made by the AI
- **Side-by-side comparison** of what changed
- **Line-by-line tracking** of modifications

## Switching Between Modes

### Toggle Controls
Located in the editor toolbar, you'll find:
- **Editor** button - Switch to normal editing mode
- **Diff** button - Switch to change tracking mode

### When to Use Each Mode
- **Use Editor Mode when:**
  - Making manual code changes
  - Writing new functionality
  - Debugging or fixing issues
  - General code development

- **Use Diff Mode when:**
  - Reviewing what the AI changed after a prompt
  - Understanding modifications before accepting them
  - Tracking the impact of AI suggestions
  - Learning from AI-generated code patterns

## Understanding Diff Visualizations

### Code Highlighting
**Additions (Green):**
- New code lines added by the AI
- New functions, components, or logic
- Enhanced features and improvements

**Deletions (Red):**
- Code removed by the AI
- Replaced or refactored sections
- Deprecated functionality

### File Tree Indicators
The file tree shows change statistics for each modified file:

**Change Indicators:**
- **`+5`** - 5 lines added to this file
- **`-3`** - 3 lines removed from this file
- **`+12 -8`** - 12 lines added, 8 lines removed
- **No indicator** - File unchanged

**Visual Cues:**
- **Green `+` symbol** indicates files with additions
- **Red `-` symbol** indicates files with deletions


# Reflex Build IDE

Reflex Build includes a **powerful, in-browser IDE** built on **Monaco Editor**, designed to make coding fast, efficient, and enjoyable—all without leaving your browser.

<div class="p-1 my-4 rounded-lg bg-slate-5">
  <iframe
    width="100%"
    height="400"
    src="https://www.youtube.com/embed/UAj9vUweQ5g"
    title="Reflex Build - IDE"
    frameborder="0"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowfullscreen>
  </iframe>
</div>


## Features

### Real-Time Editing
Edit your code and see changes reflected immediately in your project. No manual saves or rebuilds—stay focused and iterate faster.

### Syntax Highlighting & Error Detection
Write code confidently with **syntax highlighting**, **inline error alerts**, and **linting**. Catch issues as you type, reducing bugs and speeding up development.

### Code Snippets & Autocomplete
Speed up development with **autocomplete** for functions, variables, and imports, as well as reusable **code snippets** for common patterns.

### Integrated Preview
Quickly preview your changes directly in the editor without switching contexts, ensuring your app behaves as expected as you code.

### Built-In Terminal for Debugging
Use the integrated terminal to run commands, debug issues, and inspect logs—all within the IDE. No need to switch tools or tabs.


# Installing External Packages

```python exec
import reflex as rx
```

Reflex Build allows you to install external python packages to use in your app. This is useful if you want to use a package that is not included in the default Reflex Build environment. Examples might include `openai`, `langsmith`, `requests`, etc.

There are two ways to install external packages:

1. **Through the Chat Interface**: You can ask the AI to install a package for you.
2. **Add to the `requirements.txt` file**: You can add the package to the `requirements.txt` file and then save the app. This will install the package in your app's environment.

## Installing through the Chat Interface

Enter the name of the package you want to install in the chat interface. The AI will then install the package for you.

```python eval
rx.image(
    src="/ai_builder/external_packages_input.gif",
    height="auto",
    padding_bottom="2rem",
)
```


## Installing through the requirements.txt file

Add the package to the `requirements.txt` file and then save the app. This will install the package in your app's environment and recompile your app.

```python eval
rx.image(
    src="/ai_builder/external_packages_requirements.gif",
    height="auto",
    padding_bottom="2rem",
)
```

# Use Images as a prompt

```python exec
import reflex as rx
```

Uploading an image (screenshot) of a website (web) app of what you are looking to build gives the AI really good context. 

*This is the recommended way to start an app generation.*


Below is a GIF showing how to upload an image to the AI Builder:

```python eval
rx.image(
    src="/ai_builder/image_upload.gif",
    height="auto",
    padding_bottom="2rem",
)
```

The advised prompt to use is:

`Build an app from a reference image`

# Restore Checkpoint

The **Restore Checkpoint** feature allows you to roll back your app to any previous state during your AI Builder conversation. This is useful when you want to undo recent changes and return to an earlier version of your app.

```python exec
import reflex as rx
from reflex_image_zoom import image_zoom
```

```python eval
rx.el.div(
    image_zoom(
        rx.image(
            src=rx.color_mode_cond(
                "/ai_builder/features/restore_light.webp",
                "/ai_builder/features/restore_dark.webp",
            ),
            class_name="p-2 rounded-md h-auto",
            border=f"0.81px solid {rx.color('slate', 5)}",
        ),
        class_name="rounded-md overflow-hidden",
    ),
    class_name="w-full flex flex-col rounded-md cursor-pointer",
)
```

## How It Works

Every time the AI agent makes changes to your app, a checkpoint is automatically created. You can restore to any of these checkpoints at any time, effectively undoing all changes made after that point.

## Using Restore Checkpoint

1. **Locate the Restore Icon**: At the end of each AI agent message that made changes to your app, you'll see a circular arrow icon (↻).

2. **Click to Restore**: Click the circular arrow icon next to the message you want to restore to.

3. **Confirm the Action**: The app will restore to the exact state it was in after that specific message was processed.

4. **Continue Building**: After restoring, you can continue the conversation and make new changes from that point.

## When to Use Restore Checkpoint

- **Undo Unwanted Changes**: When the AI made changes you don't like
- **Try Different Approaches**: Restore and ask the AI to implement a feature differently
- **Fix Broken Functionality**: Roll back when new changes break existing features
- **Experiment Safely**: Test different solutions knowing you can always restore to a checkpoint

## Important Notes

- Restoring will **permanently delete** all changes made after the selected message
- You cannot undo a restore operation - choose your restore point carefully
- The conversation history remains intact, but code changes after the restore point are lost
- Restore checkpoint only affects your current building session

> **Tip:** Before making major changes, note which message represents your last stable checkpoint so you can easily restore if needed.


# File Tree

The **File Tree** in Reflex Build lets you **view, organize, and manage all files and folders** in your project directly from the browser. It’s your central hub for navigating your app’s structure.

## Key Features

### Creating Folders
- Click the **New Folder** button to create a folder inside the currently selected directory.
- Enter a name and press **Enter** to confirm.
- Folders can be nested to organize your project hierarchically.

### Creating Files
- Click the **New File** button to create a file inside the current folder.
- Enter a file name and extension (e.g., `main.py`) and press **Enter**.
- Files are immediately visible in the tree and ready for editing in the code editor.

### Renaming Files or Folders
- Right-click on a file or folder and select **Rename**.
- Type the new name and press **Enter** to confirm.
- Renaming automatically updates references in your project where applicable.

### Deleting Files or Folders
- Right-click on a file or folder and select **Delete**.
- Deleted items are permanently removed, so be careful when deleting important files.

### Drag-and-Drop from System
- Drag files or folders from your computer directly into the File Tree.
- The editor will automatically import them into the selected folder.
- This works for individual files or entire folder structures, making adding assets or scripts quick and easy.


# Databricks Integration

The **Databricks Integration** allows your app to connect to a Databricks workspace, query data from warehouses, and use catalogs and schemas directly in your app. This integration supports secure authentication via tokens and can be configured per environment.

```python exec
import reflex as rx
from reflex_image_zoom import image_zoom
```

```python eval
rx.el.div(
    image_zoom(
        rx.image(
            src=rx.color_mode_cond(
                "/ai_builder/integrations/databricks_light.webp",
                "/ai_builder/integrations/databricks_dark.webp",
            ),
            class_name="p-2 rounded-md h-auto",
            border=f"0.81px solid {rx.color('slate', 5)}",
        ),
        class_name="rounded-md overflow-hidden",
    ),
    class_name="w-full flex flex-col rounded-md cursor-pointer",
)
```

## Step 1: Gather Your Credentials

Before connecting, make sure you have the following information:

- **Hostname**: `https://adb-1234567890123456.7.azuredatabricks.net`
  *The URL of your Databricks workspace*

- **Personal Access Token**: `dapi1234567890abcdef1234567890abcd`
  *Used for secure authentication*

- **Warehouse / SQL Endpoint ID**: `wh-9876543210`
  *The warehouse ID you want to query*

- **Catalog**: `databricks_catalog_demo`
  *The catalog containing your databases*

- **Schema**: `demo_schema`
  *The schema inside the catalog to query*

> **Note:** Use environment-specific credentials for development, staging, and production.

## Step 2: Configure the Integration

1. Go to the **Integrations** section in your app settings by clicking **`@`** and then clicking the **Integrations** tab at the top.
2. Click **Add Databricks Integration**.
3. Fill in the fields using your credentials
4. Save the integration. Your app can now access Databricks data securely.


# Database Integration

The Database Integration allows you to connect your AI-generated applications to real databases, automatically generating schemas and enabling data-driven functionality.

```python exec
import reflex as rx
from reflex_image_zoom import image_zoom
```

```python eval
rx.el.div(
    image_zoom(
        rx.image(
            src=rx.color_mode_cond(
                "/ai_builder/integrations/database_light.webp",
                "/ai_builder/integrations/database_dark.webp",
            ),
            class_name="p-2 rounded-md h-auto",
            border=f"0.81px solid {rx.color('slate', 5)}",
        ),
        class_name="rounded-md overflow-hidden",
    ),
    class_name="w-full flex flex-col rounded-md cursor-pointer",
)
```

## Supported Databases

- **PostgreSQL** - Recommended for production applications
- **MySQL** - Popular open-source database
- **SQLite** - Lightweight database, perfect for development and small applications

## Getting Started

### Opening the Database Integration

1. Navigate to your app in the AI Builder
2. Open the **Settings drawer** (gear icon)
3. Click on the **Integrations** tab
4. Find and enable the **Database** integration

### Connection Methods

The Database Integration offers two convenient ways to connect:

#### 1. Connection Details (Recommended)

This user-friendly form breaks down your database connection into individual fields:

**For PostgreSQL and MySQL:**
- **Database Type**: Select from dropdown (PostgreSQL/MySQL)
- **Hostname**: Your database server address (e.g., `localhost`, `db.company.com`)
- **Port**: Automatically filled (PostgreSQL: 5432, MySQL: 3306) or specify custom port
- **Username**: Your database username
- **Password**: Your database password (securely handled)
- **Database Name**: The specific database to connect to

**For SQLite:**
- **Database Type**: Select "SQLite" from dropdown
- **SQLite Download URL**: Either a local file path or HTTP URL to download the database file

#### 2. Database URI

For advanced users who prefer the traditional connection string format:

**PostgreSQL:**
```
postgresql://username:password@hostname:port/database_name
```

**MySQL:**
```
mysql://username:password@hostname:port/database_name
```

**SQLite:**
```
sqlite:///path/to/database.sqlite
sqlite+https://example.com/database.sqlite
```

## Database URI Components

Protocol (postgresql://) - Database type identifier
Username (admin) - Database user credentials
Password (secret123) - User password (kept secure)
Hostname (db.company.com) - Server address
Port (5432) - Connection port
Database (mydatabase) - Target database name

## Connection Process

1. **Choose your method**: Use either Connection Details form or Database URI
2. **Fill in credentials**: Provide your database connection information
3. **Click Connect**: The system will validate and test your connection
4. **Schema Generation**: Upon successful connection, the system automatically:
   - Connects to your database
   - Analyzes the database structure
   - Generates SQLAlchemy models
   - Makes schema available to the AI for queries


# Installation

```python exec
import reflex as rx
```

```md alert warning
# The Reflex MCP integration is currently only available for enterprise customers. Please [book a demo](https://reflex.dev/pricing/) to discuss access.
```

To use the Reflex MCP integration, you'll need to configure your AI assistant or coding tool to connect to the Reflex MCP server. No additional Python packages are required on your local machine - the server is hosted and ready to use.

## Prerequisites

- An MCP-compatible AI tool (Claude Desktop, Windsurf, Codex, etc.)
- Internet connection to access the hosted MCP server
- Valid Reflex account for OAuth 2.1 authentication

## Authentication

The Reflex MCP server uses OAuth 2.1 protocol for secure authentication. You'll need a valid Reflex account, and authentication is handled automatically through your MCP client configuration when you provide your Reflex credentials.

## IDE and Coding Assistant Integration

### Claude Desktop

Add the Reflex MCP server to your Claude Desktop configuration by editing your configuration file:

```json
{
  "mcpServers": {
    "reflex": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-proxy"],
      "env": {
        "MCP_PROXY_URL": "https://mcp.reflex.dev/mcp"
      }
    }
  }
}
```

### Windsurf/Cascade

Create a `.vscode/mcp.json` file in your project root:

```json
{
  "mcpServers": {
    "reflex": {
      "serverType": "http",
      "url": "https://mcp.reflex.dev/mcp"
    }
  }
}
```

### Codex

Add this configuration to your `~/.codex/config.toml` file:

```toml
[mcp_servers.reflex]
command = "npx"
args = ["-y", "@modelcontextprotocol/server-proxy"]
env = { "MCP_PROXY_URL" = "https://mcp.reflex.dev/mcp" }
```

Note: Codex requires MCP servers to communicate over stdio. The `@modelcontextprotocol/server-proxy` adapter bridges the connection to the HTTP-based Reflex MCP server.


# Azure Auth Manager Integration

The **Azure Auth Manager Integration** allows your app to authenticate users through Microsoft Azure Active Directory (Azure AD). This integration provides secure OAuth 2.0 authentication and supports multi-tenant applications with customizable tenant access.

```python exec
import reflex as rx
from reflex_image_zoom import image_zoom
```

```python eval
rx.el.div(
    image_zoom(
        rx.image(
            src=rx.color_mode_cond(
                "/ai_builder/integrations/azure_auth_light.webp",
                "/ai_builder/integrations/azure_auth_dark.webp",
            ),
            class_name="p-2 rounded-md h-auto",
            border=f"0.81px solid {rx.color('slate', 5)}",
        ),
        class_name="rounded-md overflow-hidden",
    ),
    class_name="w-full flex flex-col rounded-md cursor-pointer",
)
```

## Step 1: Set Up Azure App Registration

Before connecting, you need to register your app in Azure Portal:

1. Go to [Azure Portal](https://portal.azure.com) → **App Registrations**
2. Click **New registration**
3. Configure your app settings
4. In **Authentication**, add the Web Redirect URI: `https://3a992b51-c34a-405a-b90c-4b3320eb3b6a.fly.dev/authorization-code/callback`

## Step 2: Gather Your Credentials

After registering your app, collect the following information:

- **AZURE_CLIENT_ID**: `12345678-1234-1234-1234-123456789abc`
  *Your application (client) ID from App Registration*

- **AZURE_CLIENT_SECRET**: `abcdef123456~ABCdef123456-ABCdef123456`
  *Client secret generated in Certificates & secrets*

- **AZURE_VALID_TENANT_IDS**: `87654321-4321-4321-4321-210987654321`
  *Comma-separated list of tenant IDs that can access your app*

> **Note:** Keep your client secret secure and use different registrations for development, staging, and production environments.

## Step 3: Configure the Integration

1. Go to the **Integrations** section in your app settings by clicking **`@`** and then clicking the **Integrations** tab at the top.
2. Click **Add** next to Azure Auth Manager.
3. Fill in the credential fields:
   - Enter your Azure Client ID
   - Enter your Azure Client Secret
   - Enter valid tenant IDs (comma-separated for multiple tenants)
4. Click **Connect** to save the integration.

Your app can now authenticate users through Azure AD with secure OAuth 2.0 flow.


# Google Auth Integration

The **Google Auth Integration** allows your app to authenticate users using their Google accounts. This provides a secure, familiar login experience and simplifies user management.

```python exec
import reflex as rx
from reflex_image_zoom import image_zoom
```

```python eval
rx.el.div(
    image_zoom(
        rx.image(
            src=rx.color_mode_cond(
                "/ai_builder/integrations/google_light.webp",
                "/ai_builder/integrations/google_dark.webp",
            ),
            class_name="p-2 rounded-md h-auto",
            border=f"0.81px solid {rx.color('slate', 5)}",
        ),
        class_name="rounded-md overflow-hidden",
    ),
    class_name="w-full flex flex-col rounded-md cursor-pointer",
)
```

## Step 1: Create a Google OAuth Client

1. Go to the [Google Cloud Console](https://console.cloud.google.com/).
2. Navigate to **APIs & Services → Credentials**.
3. Click **Create Credentials → OAuth Client ID**.
4. Select **Web Application** as the application type.
5. Add the following **Authorized JavaScript Origin**:
   - https://3a992b51-c34a-405a-b90c-4b3320eb3b6a.fly.dev
   - The URL can be copied directly from the Google Auth integration panel.
6. Set your authorized redirect URIs to match your app environment.
7. Save the client and copy the following credentials:
   - **Client ID**: `YOUR_GOOGLE_CLIENT_ID`
   - **Client Secret**: `YOUR_GOOGLE_CLIENT_SECRET`

## Step 2: Configure the Integration in Your App

1. Go to **Integrations → Add Google Auth** in your app settings.
2. Enter your **Google Client ID** and **Google Client Secret**.
3. Save the integration. Your app is now configured to use Google Auth for login.

## Step 3: Notes

- The integration supports multiple environments (development, staging, production). Use environment-specific secrets for the client ID and secret.
- Google Auth handles token refresh automatically when users log in via OAuth.
- Users will see a standard Google login screen, ensuring familiarity and trust.
- Ensure your app domain matches the authorized JavaScript origin and redirect URIs; otherwise, authentication will fail.


# Overview

```python exec
import reflex as rx
```

```md alert warning
# The Reflex MCP integration is currently only available for enterprise customers. Please [book a demo](https://reflex.dev/pricing/) to discuss access.
```

The Reflex [Model Context Protocol (MCP)](https://modelcontextprotocol.io/) integration provides AI assistants and coding tools with structured access to Reflex framework documentation and component information. This enables intelligent assistance while developing Reflex applications.

The Reflex MCP server is deployed at `https://mcp.reflex.dev/mcp` and provides access to component documentation and Reflex documentation through standardized MCP tools.

## Available Tools

The Reflex MCP server provides tools for accessing component documentation and Reflex documentation through standardized MCP capabilities.

## Enterprise Use

For enterprise customers requiring on-premises deployment of the Reflex MCP server, please [book a demo](https://reflex.dev/pricing/) to discuss your requirements.


# OpenAI Integration

The **OpenAI Integration** allows your app to use OpenAI APIs for features such as text generation, embeddings, and other AI-powered functionality.



```python exec
import reflex as rx
from reflex_image_zoom import image_zoom
```

```python eval
rx.el.div(
    image_zoom(
        rx.image(
            src=rx.color_mode_cond(
                "/ai_builder/integrations/open_ai_light.webp",
                "/ai_builder/integrations/open_ai_dark.webp",
            ),
            class_name="p-2 rounded-md h-auto",
            border=f"0.81px solid {rx.color('slate', 5)}",
        ),
        class_name="rounded-md overflow-hidden",
    ),
    class_name="w-full flex flex-col rounded-md cursor-pointer",
)
```

## Step 1: Obtain an OpenAI API Key

1. Go to the [OpenAI Platform](https://platform.openai.com/).
2. Navigate to **API Keys** in your account settings.
3. Click **Create new secret key**.
4. Copy the generated key.
   - Example: `sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx`


## Step 2: Configure the Integration in Your App

1. Go to **Integrations → Add OpenAI Integration** in your app settings.
2. Enter your **OpenAI API Key** in the input field.
3. Save the integration. Your app is now ready to make OpenAI API requests.

---

## Step 3: Notes

- Keep your OpenAI key secure; do **not** hardcode it in public code repositories.
- Use environment-specific secrets if you have separate development, staging, and production environments.
- The key allows your app to interact with OpenAI endpoints securely and efficiently.


# Connecting to Github

```python exec
import reflex as rx
from reflex_image_zoom import image_zoom
```

The Github integration is important to make sure that you don't lose your progress. It also allows you to revert to previous versions of your app. 


```python eval
rx.image(
    src="/ai_builder/connecting_to_github.gif",
    height="auto",
    padding_bottom="2rem",
)
```

The GitHub integration allows you to:

- Save your app progress
- Work on your code locally and push your local changes back to Reflex.Build


## Github Commit History

The commit history is a great way to see the changes that you have made to your app. You can also revert to previous versions of your app from here. 

```python eval
image_zoom(rx.image(src="/ai_builder/github_commit_history.png"))
```



# Reflex Build: Best Practices

> A comprehensive guide to working effectively with AI Builder. This guide outlines how to get the most reliable and efficient results when working with the AI Builder inside Reflex Build. The key to success is clarity, structure, and iteration.

---

## Core Workflow

### Foundation: Planning Before You Build

Before jumping into the AI Builder, take time to plan your approach. Good preparation leads to better results and fewer iterations.

- **Define your core purpose and users** — Write a 2-3 sentence app description and identify your target users and their needs.
- **Prioritize 3-5 key features** — Focus on the most important functionality first, then expand from there.
- **Gather visual references** — Collect screenshots, wireframes, or sketches of layouts you want to emulate.
- **Structure your data** — List what information each page needs to display and how users will interact with it.
- **Start with your most important page** — Usually your main dashboard, home screen, or primary workflow. Get this right first.

### Auto-Generate Prompts from App Specs

To save time and get higher-quality prompts, you can feed your full app spec into **Chat Mode** and ask it to break the spec into structured, build-ready prompts.

Chat Mode can translate your vision into:

- Layout instructions
- UI component definitions
- Data model requirements
- Styling preferences
- Follow-up test plans

Once generated, copy each prompt into the AI Builder to execute them in sequence.

**Example workflow:**

1. Switch to Chat Mode and paste your full app specification
2. Ask **"Break this into a series of buildable prompts I can feed into the Agent Mode."**
3. Copy each generated prompt into Agent Mode one by one
4. Build iteratively using the structured prompts

### Working with Text Specifications

If you have a structured app specification, don't paste the entire document into the builder at once. Break it down into logical sections and feed them in sequence.

**Pro tip:** Use **Chat Mode** to help prepare prompts:

Paste your full app spec and ask:

  - **"Break this into buildable prompts I can feed into the builder."**
  - **"Write one prompt per feature/page to build this app."**

This hybrid approach — planning in **Chat Mode**, then building in **Agent Mode** — lets you move faster and build smarter.

### Writing Clear, Task-Oriented Prompts

The AI performs best when it receives **specific, outcome-driven instructions**. Avoid vague, broad prompts.


```diff
- Build me an admin dashboard. # <- Bad
+ Create a 2-column layout with a sidebar for navigation and a top navbar. # <- Good
```

Whenever possible, split large tasks into smaller steps:

- Define the layout first (columns, rows, sidebar)
- Add UI components (buttons, inputs, modals)
- Handle data models and states later
- Use follow-ups to style and polish

Use precise styling language, for example:

```diff
- Grid items have small spacing and sharp corners.
+ Add medium spacing between grid items and use large rounded corners on cards.
```

Avoid subjective terms like "**nice**," "**modern**," or "**clean**." Treat your prompt as interface documentation for the builder.

### Working with Images and Visual References

You can drop in screenshots of websites, dashboards, apps, or even hand-drawn wireframes. The builder will extract layout, design, and functionality ideas from these images.

**Tips for images:**

- Clear screenshots work best
- Include any elements you want: forms, tables, nav, charts
- You can annotate them with arrows, notes, or labels

**Get UI/UX feedback using Chat Mode:**

Upload a screenshot and ask: **"What are 5 things I could do to improve the UI/UX of this?"**


Follow up with: **Implement items 1, 2, and 4 in the builder.**

Or request specific improvements: **Make this more minimal and mobile-first.**

---

## Optimizing Your Workflow

### Building Iteratively

Trying to generate your full app in a single prompt almost never works well. Instead, approach your build in clear stages:

1. **Layout** — Grid, Flex, responsive columns/rows
2. **Components** — Tables, buttons, modals, charts, etc.
3. **State** — Bindings, stores, mock data
4. **Refinement** — Tweaks, visual polish, edge case handling

At each stage, give feedback and iterate. If the AI builder makes something close, you can say:

```diff
- Modal is included and sidebar is static.
+ Remove modal and make sidebar collapsible.

- Buttons vary across pages.
+ Use same button style from home page.

- Card layout differs across sections.
+ Repeat card layout from dashboard section.
```


### Improving UI/UX

To improve your design, ask the builder for more polished layouts, better structure, or more modern styles.

```diff
- Layout feels cluttered with small headings and dense sections.
+ Increase heading sizes and spacing between sections for better hierarchy.

- Navigation buttons are inconsistent.
+ Standardize button sizes and colors for consistent UX.
```

**Suggested workflow:**

1. In Chat Mode, upload an image or describe the layout.
2. Ask: **"Tell me 5 things that would improve the UI/UX of this page."**
3. Review the suggestions and decide which ones you want to apply.
4. Switch to Agent Mode and implement: **"Improve visual hierarchy by increasing heading sizes and adding more spacing between sections."**

### Using Knowledge to Guide the Build

The **Knowledge** panel lets you provide long-form references that influence how the agent builds your app. Add design systems, style guides, brand guidelines, or architecture rules.

Once added, the builder will try to honor these rules throughout the session, ensuring consistency without repeating instructions.

Try combining Knowledge with Chat Mode:

  - **Use the style guide in Knowledge to improve this page.**

  - **Is the current layout aligned with our design system in Knowledge?**


### Local Development Integration

We have an MCP server available for enterprise customers to connect local AI development tools such as Claude Desktop, Windsurf, or Codex.

This enables a hybrid workflow: generate your app and make major changes in the App Builder, then move to local development for detailed refinements and custom functionality.

> **Enterprise Feature:** The Reflex MCP integration is currently only available for enterprise customers. [Book a demo](https://reflex.dev/pricing/) to discuss access.

#### Quick Setup

**Prerequisites:**

- MCP-compatible AI tool (Claude Desktop, Windsurf, Codex)
- Valid Reflex account for OAuth authentication
- Internet connection to the hosted MCP server

**Benefits:**

- **Seamless handoff** — Move between web builder and local development
- **AI-powered local development** — Use your preferred AI tools with Reflex projects
- **No local installation** — Hosted MCP server requires no additional Python packages
- **Secure authentication** — OAuth 2.1 integration with your Reflex account

For complete setup instructions for Claude Desktop, Windsurf, Codex, and other MCP clients, visit our [MCP integration](https://reflex.dev/docs/ai-builder/integrations/mcp-installation/) documentation.

---

## Key Takeaways

- **Plan before you build**. A few minutes of preparation saves hours of iteration.
- **Think modularly**. Focus on atomic parts before the full system.
- **Write like a designer-developer**. Clear, structural, and functional language wins.
- **Iterate continuously**. Let each prompt get you 80% there, then refine.

With these techniques, the AI Builder becomes a reliable extension of your creative and technical intent.


# Your First Reflex Build App

In this tutorial, you'll build a data dashboard application that displays employee information in both table and chart formats, with interactive features for filtering and adding new data. We'll also add a simple chatbot page to demonstrate multi-page navigation.

## What You'll Build

By the end of this tutorial, you'll have created:
- A dashboard displaying employee data in a table and bar chart
- Interactive filtering to search through your data
- A modal form for adding new employees
- A separate page with a simple chatbot interface

This tutorial assumes you're starting with a new project in AI Builder.

---

## Creating Your Dashboard

Let's start by building the core of our application - a dashboard that displays employee data.

**Prompt:**
```
Create a dashboard page with a table showing sample employee data with columns: Name, Department, and Salary. Below the table, add a bar chart that visualizes the salary data. Include at least 5 sample employees with different departments and salary ranges.
```

This will create your main dashboard page with both tabular and visual representations of your data. The AI will generate sample employee records and create a bar chart that makes it easy to compare salaries across your team.

```python exec
import reflex as rx
from reflex_image_zoom import image_zoom
```

```python eval
rx.el.div(
    image_zoom(
        rx.image(
            src=rx.color_mode_cond(
                "/ai_builder/overview/tutorial_1_light.webp",
                "/ai_builder/overview/tutorial_1_dark.webp",
            ),
            class_name="p-2 rounded-md h-auto",
            border=f"0.81px solid {rx.color('slate', 5)}",
        ),
        class_name="rounded-md overflow-hidden",
    ),
    class_name="w-full flex flex-col rounded-md cursor-pointer",
)
```

## Adding Interactive Filtering

Now that you have your basic dashboard, let's make it more interactive by adding the ability to filter and search through your employee data.

**Prompt:**
```
Add filtering functionality to the employee table. Include a search input above the table that filters rows based on name, and dropdown filters for department. Make sure the filters work together and update the table in real-time.
```

Your dashboard now becomes much more useful with real-time filtering. Users can quickly find specific employees by name or narrow down results by department. The filters work together, so you can combine a department filter with a name search.

```python eval
rx.el.div(
    image_zoom(
        rx.image(
            src=rx.color_mode_cond(
                "/ai_builder/overview/tutorial_2_light.webp",
                "/ai_builder/overview/tutorial_2_dark.webp",
            ),
            class_name="p-2 rounded-md h-auto",
            border=f"0.81px solid {rx.color('slate', 5)}",
        ),
        class_name="rounded-md overflow-hidden",
    ),
    class_name="w-full flex flex-col rounded-md cursor-pointer",
)
```


## Enabling Data Entry

A static dashboard is useful, but being able to add new data makes your app much more practical. Let's add the ability to create new employee records.

**Prompt:**
```
Add an "Add Employee" button above the table. When clicked, open a modal with input fields for Name, Department, and Salary. When the form is submitted, add the new employee to the table and update the bar chart. Include form validation for required fields.
```

Your app now has full CRUD capability for employee records. The modal form provides a clean interface for data entry, and both your table and chart update immediately when new employees are added.


```python eval
rx.el.div(
    image_zoom(
        rx.image(
            src=rx.color_mode_cond(
                "/ai_builder/overview/tutorial_3_light.webp",
                "/ai_builder/overview/tutorial_3_dark.webp",
            ),
            class_name="p-2 rounded-md h-auto",
            border=f"0.81px solid {rx.color('slate', 5)}",
        ),
        class_name="rounded-md overflow-hidden",
    ),
    class_name="w-full flex flex-col rounded-md cursor-pointer",
)
```


## Building a Multi-Page App

Most real applications have multiple pages. Let's add a chatbot page to demonstrate navigation and create a more complete user experience.

**Prompt:**
```
Create a new page called "Chat" and add it to the navigation. Build a simple chatbot interface with a message input field, send button, and chat history display. For now, make the bot echo back the user's messages with "Bot says: [user message]".
```

Your app now has proper navigation between the dashboard and chat functionality. The chatbot page demonstrates how easy it is to add new features and pages to your AI Builder application.


```python eval
rx.el.div(
    image_zoom(
        rx.image(
            src=rx.color_mode_cond(
                "/ai_builder/overview/tutorial_4_light.webp",
                "/ai_builder/overview/tutorial_4_dark.webp",
            ),
            class_name="p-2 rounded-md h-auto",
            border=f"0.81px solid {rx.color('slate', 5)}",
        ),
        class_name="rounded-md overflow-hidden",
    ),
    class_name="w-full flex flex-col rounded-md cursor-pointer",
)
```

## What's Next?

You've successfully built a complete web application with data visualization, interactive filtering, data entry, and multi-page navigation. Your app demonstrates many common patterns used in modern web applications:

- **Data presentation** with tables and charts
- **User interaction** through filtering and forms
- **Real-time updates** when data changes
- **Multi-page architecture** with navigation

## Exploring Further

Now that you have a working foundation, try experimenting with these ideas:

- **Customize the data model** - change the employee fields or add new columns
- **Enhance the visualizations** - try different chart types or add more charts
- **Improve the chatbot** - give it more sophisticated responses or integrate it with your employee data
- **Add more pages** - create additional features like employee profiles or reporting dashboards

The power of AI Builder is that you can iterate quickly with natural language prompts. Each new feature is just a conversation away!


# What Is Reflex Build

Reflex Build is an AI-powered platform that lets anyone create full-stack web apps just by describing ideas in plain English—no coding needed. It includes a full-fledged built-in IDE, real-time collaboration (beta), and project sharing—all in your browser, no installation required.

```python exec
from typing import List, TypedDict

import reflex as rx
from reflex_image_zoom import image_zoom


class Feature(TypedDict):
    title: str
    description: str
    icon: str


class LandingState(rx.State):
    features: List[Feature] = [
        {
            "title": "Database Integration",
            "description": "Automatically integrate your database\ninto your application with ease",
            "icon": "database",
        },
        {
            "title": "Secure Secrets",
            "description": "Safely manage your API keys and tokens\nwith a built in secrets manager",
            "icon": "shield",
        },
        {
            "title": "Live Preview",
            "description": "See all application changes in real-time\nwith our interactive preview tab",
            "icon": "eye",
        },
        {
            "title": "Quick Download",
            "description": "Download your complete project files\nwith just a single click operation",
            "icon": "download",
        },
        {
            "title": "Easy Deployment",
            "description": "Deploy your application to production\nwith just a single click process",
            "icon": "rocket",
        },
        {
            "title": "Manual File Editing",
            "description": "Edit your project files directly\nwith our intuitive code editor",
            "icon": "code",
        },
        {
            "title": "AI Package Manager",
            "description": "Let AI handle your package installations\nvia natural prompting",
            "icon": "sparkles",
        },
        {
            "title": "Smart Prompting",
            "description": "Get better development results\nwith AI-optimized prompt templates",
            "icon": "message-circle",
        },
    ]


class BuildDocState(rx.State):
    current_feature: dict[str, str] = {
        "light": "/ai_builder/what_is_reflex_build/project_bar_light.webp",
        "dark": "/ai_builder/what_is_reflex_build/project_bar_dark.webp",
    }

    image_opacity: float = 1.0  # Use float instead of string for opacity
    transition_in_progress: bool = False

    features: list[dict[str, str | dict[str, str]]] = [
        {
            "title": "Project Menu Bar",
            "subtitle": "Browse previously built applications, create new sessions, store database variables, and much more!",
            "img": {
                "light": "/ai_builder/what_is_reflex_build/project_bar_light.webp",
                "dark": "/ai_builder/what_is_reflex_build/project_bar_dark.webp",
            },
            "selected": True,
        },
        {
            "title": "Chat Area",
            "subtitle": "See your prompts in action with visual cues, editing notifications, and file generations every step of the way.",
            "img": {
                "light": "/ai_builder/what_is_reflex_build/chat_light.webp",
                "dark": "/ai_builder/what_is_reflex_build/chat_dark.webp",
            },
            "selected": False,
        },
        {
            "title": "Application Workspace",
            "subtitle": "Your workspace contains all the folders and files of your application. You can add new files and folders as well!",
            "img": {
                "light": "/ai_builder/what_is_reflex_build/file_tree_light.webp",
                "dark": "/ai_builder/what_is_reflex_build/file_tree_dark.webp",
            },
            "selected": False,
        },
        {
            "title": "Code Editor",
            "subtitle": "The code editor displays the current selected file. You can edit the code directly and save it instantly.",
            "img": {
                "light": "/ai_builder/what_is_reflex_build/code_light.webp",
                "dark": "/ai_builder/what_is_reflex_build/code_dark.webp",
            },
            "selected": False,
        },
        {
            "title": "Bottom Menu Bar",
            "subtitle": "This menu contains important actions such as deploying, downloading, and sharing your application.",
            "img": {
                "light": "/ai_builder/what_is_reflex_build/bottom_light.webp",
                "dark": "/ai_builder/what_is_reflex_build/bottom_dark.webp",
            },
            "selected": False,
        },
        {
            "title": "Preview Tab",
            "subtitle": "The preview tab showcases a live application. You can navigate to other applications directly from this tab, refresh the app, and even view it in full screen.",
            "img": {
                "light": "/ai_builder/what_is_reflex_build/preview_light.webp",
                "dark": "/ai_builder/what_is_reflex_build/preview_dark.webp",
            },
            "selected": False,
        },
    ]

    @rx.event(background=True)
    async def select_feature(self, index: int):
        import asyncio

        # Prevent multiple transitions at once
        if self.transition_in_progress:
            return

        # Update the selected feature and image
        async with self:
            for i, feature in enumerate(self.features):
                feature["selected"] = i == index

            self.transition_in_progress = True

            # Fade out
            self.image_opacity = 0.0
            yield
            await asyncio.sleep(0.1)

            self.current_feature = self.features[index]["img"]
            await asyncio.sleep(0.2)

            # # Fade in
            self.image_opacity = 1.0
            self.transition_in_progress = False


feature_images = [
    [
        "/ai_builder/what_is_reflex_build/project_bar_light.webp",
        "/ai_builder/what_is_reflex_build/project_bar_dark.webp",
        "Project Menu Bar",
        "Browse previously built applications, create new sessions, store database variables, and much more!",
    ],
    [
        "/ai_builder/what_is_reflex_build/chat_light.webp",
        "/ai_builder/what_is_reflex_build/chat_dark.webp",
        "Chat Area",
        "See your prompts in action with visual cues, editing notifications, and file generations every step of the way.",
    ],
    [
        "/ai_builder/what_is_reflex_build/file_tree_light.webp",
        "/ai_builder/what_is_reflex_build/file_tree_dark.webp",
        "Application Workspace",
        "Your workspace contains all the folders and files of your application. You can add new files and folders as well!",
    ],
    [
        "/ai_builder/what_is_reflex_build/code_light.webp",
        "/ai_builder/what_is_reflex_build/code_dark.webp",
        "Code Editor",
        "The code editor displays the current selected file. You can edit the code directly and save it instantly.",
    ],
    [
        "/ai_builder/what_is_reflex_build/bottom_light.webp",
        "/ai_builder/what_is_reflex_build/bottom_dark.webp",
        "Bottom Menu Bar",
        "This menu contains important actions such as deploying, downloading, and sharing your application.",
    ],
    [
        "/ai_builder/what_is_reflex_build/preview_light.webp",
        "/ai_builder/what_is_reflex_build/preview_dark.webp",
        "Preview Tab",
        "The preview tab showcases a live application. You can navigate to other applications directly from this tab, refresh the app, and even view it in full screen.",
    ],
]


def feature_card(feature: dict) -> rx.Component:
    return rx.el.div(
        rx.el.div(
            rx.el.span(
                rx.icon(
                    tag=feature["icon"],
                    size=15,
                    class_name="inline-block mr-2 "
                    + rx.color_mode_cond(
                        "stroke-violet-8",
                        "stroke-violet-9",
                    ),
                ),
                rx.el.span(f"{feature['title']} ", class_name="text-sm font-bold"),
                class_name="text-sm font-medium block align-center pt-5 px-2",
            ),
            rx.el.span(
                feature["description"],
                class_name="text-sm font-regular block align-center px-2",
            ),
            class_name="flex flex-col",
        ),
        class_name="w-full rounded-md",
    )


def _docs_features() -> rx.Component:
    return rx.el.div(
        rx.el.div(
            rx.foreach(LandingState.features, feature_card),
            class_name="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-2 lg:grid-cols-2 gap-4",
        ),
        class_name="flex flex-col w-full h-full justify-start align-start items-start py-4 gap-x-4 z-[99]",
    )


def _docs_app_section_features_small_screen(feature: list[str]):
    return rx.el.div(
        image_zoom(
            rx.image(
                src=rx.color_mode_cond(feature[0], feature[1]),
                class_name="p-2 rounded-md h-auto",
                border=f"0.81px solid {rx.color('slate', 5)}",
            ),
            class_name="rounded-md overflow-hidden",
        ),
        rx.el.div(
            rx.el.label(feature[2], class_name="text-sm font-bold cursor-pointer"),
            rx.el.label(feature[3], class_name="text-sm font-light cursor-pointer"),
            class_name="flex flex-col px-1 py-2",
        ),
        class_name="w-full flex flex-col rounded-md cursor-pointer",
    )


def _docs_app_section_toggles(feature: dict, index: int):
    return rx.el.div(
        rx.el.label(feature["title"], class_name="text-sm font-bold cursor-pointer"),
        rx.el.label(
            feature["subtitle"], class_name="text-sm font-light cursor-pointer"
        ),
        on_click=BuildDocState.select_feature(index),
        class_name="w-full flex flex-col max-w-md rounded-md p-4 cursor-pointer "
        + rx.cond(
            feature["selected"],
            "",
            rx.color_mode_cond("hover:bg-slate-5", "hover:bg-slate-3"),
        ),
        border=rx.cond(
            feature["selected"],
            f"0.81px solid {rx.color('purple', 7)}",
            "",
        ),
        box_shadow=rx.cond(
            feature["selected"],
            rx.color_mode_cond(
                "5px 5px oklch(0.946 0.033 307.174 / 0.5)",
                "",
            ),
            "",
        ),
    )


def _docs_app_sections():
    return rx.el.div(
        rx.el.div(
            rx.el.div(
                rx.el.label(
                    "Small details, big impact", class_name="text-sm font-light"
                ),
                rx.el.label(
                    "Made With Exceptional Care", class_name="text-3xl font-bold"
                ),
                rx.el.label(
                    "Every feature in Reflex Build is carefully crafted to set new standards. Mediocre isn't an option.",
                    class_name="text-md font-regular",
                ),
                class_name="flex flex-col w-full max-w-lg gap-y-1",
            ),
            rx.foreach(
                BuildDocState.features[:5],
                lambda feature, index: _docs_app_section_toggles(feature, index),
            ),
            class_name="flex flex-col gap-y-4 justify-start max-w-sm",
        ),
        rx.el.div(
            image_zoom(
                rx.image(
                    src=rx.color_mode_cond(
                        BuildDocState.current_feature["light"],
                        BuildDocState.current_feature["dark"],
                    ),
                    class_name="p-2 rounded-md h-auto",
                    border=f"0.81px solid {rx.color('slate', 5)}",
                ),
                class_name="rounded-md overflow-hidden",
            ),
            style={
                "opacity": f"{BuildDocState.image_opacity}",
                "transition": "opacity 300ms ease-in-out",
            },
            class_name="w-full max-w-4xl",
        ),
        class_name="flex flex-row w-full h-full justify-between align-center items-center py-4 gap-x-4 z-[99]",
        display=["none" if i <= 4 else "flex" for i in range(6)],
    )


def _docs_app_sections_small_screen():
    return rx.el.div(
        rx.el.div(
            rx.grid(
                rx.foreach(
                    feature_images,
                    lambda feature: _docs_app_section_features_small_screen(feature),
                ),
                class_name="grid grid-cols-1 sm:grid-cols-1 md:grid-cols-2 lg:grid-cols-2 gap-10 w-full",
            ),
            class_name="flex flex-col gap-y-4 justify-start py-4",
        ),
    )






screen_normalization = (
        "z-[99] w-full"
    )
```


## Feature Overview

Reflex Build provides a streamlined interface for building AI applications. The **Project Menu Bar** helps you manage sessions and stored variables, while the **Chat Area** displays real-time prompts, edits, and file generations. The **Application Workspace** organizes your project structure, and the **Code Editor** allows direct, instant code editing. Key actions like deploy and share are accessible via the **Bottom Menu Bar**, and the **Preview Tab** lets you view and interact with your live app at any time.

```python eval
rx.el.div(
    _docs_app_sections_small_screen(),
)
```

## Interface Highlights

Reflex Build’s interface is designed for clarity and efficiency. The **Project Menu Bar** helps you manage sessions, apps, and variables. The **Chat Area** shows prompts in action with visual feedback and file generation. In the **Application Workspace**, you can view and organize your project files. The **Code Editor** allows quick, direct edits with instant saving. Use the **Bottom Menu Bar** for key actions like deploy and download. The **Preview Tab** lets you interact with a live version of your app, including refresh and full-screen options.

```python eval
rx.el.div(
    rx.el.div(_docs_features(), class_name=screen_normalization),
)
```


# Templates

Reflex has many certified templates, seen on the `Trending` tab of the Reflex Build, that can be used to kickstart your app.

```python exec
import reflex as rx
from reflex_image_zoom import image_zoom
```

```python eval
rx.el.div(
    image_zoom(
        rx.image(
            src=rx.color_mode_cond(
                "/ai_builder/overview/templates_light.webp",
                "/ai_builder/overview/templates_dark.webp",
            ),
            class_name="p-2 rounded-md h-auto",
            border=f"0.81px solid {rx.color('slate', 5)}",
        ),
        class_name="rounded-md overflow-hidden",
    ),
    class_name="w-full flex flex-col rounded-md cursor-pointer",
)
```

## Using a Template

To use a template, simply click the template and then in the bottom right corner of the app click the `Fork` button. This will create a copy of the template in your own account. You can then edit the app as you like with further prompting.

```python eval
rx.el.div(
    image_zoom(
        rx.image(
            src=rx.color_mode_cond(
                "/ai_builder/overview/fork_template_light.webp",
                "/ai_builder/overview/fork_template_dark.webp",
            ),
            class_name="p-2 rounded-md h-auto",
            border=f"0.81px solid {rx.color('slate', 5)}",
        ),
        class_name="rounded-md overflow-hidden",
    ),
    class_name="w-full flex flex-col rounded-md cursor-pointer",
)
```

Templates are great to get started if they have similar UI to what you are looking to build. You can then add your own data to the app.


# General App Settings

The **General App Settings** section lets you manage key aspects of your app, including its name, ID, and deletion. This is your central place to view and update your app’s core information.


```python exec
import reflex as rx
from reflex_image_zoom import image_zoom

def render_image():
    return rx.el.div(
        image_zoom(
            rx.image(
                src=rx.color_mode_cond(
                    "/ai_builder/app_lifecycle/general_light.webp",
                    "/ai_builder/app_lifecycle/general_dark.webp",
                ),
                class_name="p-2 rounded-md h-auto",
                border=f"0.81px solid {rx.color('slate', 5)}",
            ),
            class_name="rounded-md overflow-hidden",
        ),
        class_name="w-full flex flex-col rounded-md cursor-pointer",
    )
```

```python eval

rx.el.div(render_image())

```


## How to Access Settings

1. In the AI Builder workspace, click the **Settings** icon located at the bottom-left of the screen, inside the chat box area.
2. This will open the **General** tab to see your app’s main settings.

## What You Can Do

- **Change App Name**
  Update the name of your app to reflect its purpose or version.

- **View App ID**
  Find the unique identifier for your app, which can be used for integrations or support.

- **Delete App**
  Permanently remove an app you no longer need. **Warning:** This action cannot be undone.


# Copy App

The **Copy** feature lets you duplicate an existing app inside Reflex Build.
This is useful when you want to experiment with changes without affecting the original project, or when you want to use an app as a starting point for a new idea.


```python exec
import reflex as rx
from reflex_image_zoom import image_zoom

def render_image():
    return rx.el.div(
        image_zoom(
            rx.image(
                src=rx.color_mode_cond(
                    "/ai_builder/app_lifecycle/copy_light.webp",
                    "/ai_builder/app_lifecycle/copy_dark.webp",
                ),
                class_name="p-2 rounded-md h-auto",
                border=f"0.81px solid {rx.color('slate', 5)}",
            ),
            class_name="rounded-md overflow-hidden",
        ),
        class_name="w-full flex flex-col rounded-md cursor-pointer",
    )
```

```python eval

rx.el.div(render_image())

```

## How to Copy an App

1. In the Reflex Build workspace, click the **Copy** button (bottom-right corner).
2. Reflex Build will create a new app in your workspace with the same:
   - Code files and components
   - State and configuration
   - Dependencies

The copied app will appear as a separate project, independent from the original.


## Common Use Cases

- **Experiment Safely**
  Try out new components, layouts, or integrations without risking your working app.

- **Create Variations**
  Use the original app as a base to quickly spin up a different version (e.g., a light and dark theme version).

- **Template Reuse**
  Turn an app into a personal template and copy it each time you start a new project.

## Best Practices

- Rename your copied app immediately so it’s easy to distinguish from the original.


# Deploy App

```python exec
import reflex as rx
```

It is easy to deploy your app into production from Reflex Build to Reflex Cloud.

Simply click the `Deploy` button in the bottom right corner of Reflex Build, as shown below:



```python exec
import reflex as rx
from reflex_image_zoom import image_zoom

def render_image():
    return rx.el.div(
        image_zoom(
            rx.image(
                src=rx.color_mode_cond(
                    "/ai_builder/app_lifecycle/deploy_light.webp",
                    "/ai_builder/app_lifecycle/deploy_dark.webp",
                ),
                class_name="p-2 rounded-md h-auto",
                border=f"0.81px solid {rx.color('slate', 5)}",
            ),
            class_name="rounded-md overflow-hidden",
        ),
        class_name="w-full flex flex-col rounded-md cursor-pointer",
    )
```

```python eval

rx.el.div(render_image())

```

When deploying you can set the following options:
- **App Name**: The name of your app
- **Hostname**: Set your url by setting your hostname, i.e. if you set `myapp` as your hostname, your app will be available at `myapp.reflex.run`
- **Region**: The regions where your app will be deployed
- **VM Size**: The size of the VM where your app will be deployed
- **Secrets**: The environment variables that will be set for your app, you can load the variables currently being used by your app by clicking the `Load from settings` button

Note: Hostname customization, region selection, and VM sizing are only available on paid plans.


# Download App

You can download your Reflex Build project if you want to work on it locally or self-host it outside the AI Builder.

**Tip:** The recommended workflow is to use the GitHub integration, which keeps your code version-controlled and in sync. Downloading is useful if GitHub integration isn’t available or you just want a one-time export.


```python exec
import reflex as rx
from reflex_image_zoom import image_zoom

def render_image():
    return rx.el.div(
        image_zoom(
            rx.image(
                src=rx.color_mode_cond(
                    "/ai_builder/app_lifecycle/download_light.webp",
                    "/ai_builder/app_lifecycle/download_dark.webp",
                ),
                class_name="p-2 rounded-md h-auto",
                border=f"0.81px solid {rx.color('slate', 5)}",
            ),
            class_name="rounded-md overflow-hidden",
        ),
        class_name="w-full flex flex-col rounded-md cursor-pointer",
    )
```

```python eval

rx.el.div(render_image())

```

## How to Download

1. In the AI Builder workspace, go to the **bottom-right corner**.
2. Click the **Download** button.
3. A `.zip` file will be generated containing your entire Reflex app, including:
   - Source code (`.py` files, components, state, etc.)
   - `requirements.txt` with dependencies
   - Config files (`rxconfig.py`, `.env`, etc.)


# Fork App

The **Fork App** feature lets you take an existing app and create your own version of it. This is perfect for **experimenting, customizing, or building on top of someone else’s work** without affecting the original app.

```python exec
import reflex as rx
from reflex_image_zoom import image_zoom
```

```python eval
rx.el.div(
    image_zoom(
        rx.image(
            src=rx.color_mode_cond(
                "/ai_builder/overview/fork_template_light.webp",
                "/ai_builder/overview/fork_template_dark.webp",
            ),
            class_name="p-2 rounded-md h-auto",
            border=f"0.81px solid {rx.color('slate', 5)}",
        ),
        class_name="rounded-md overflow-hidden",
    ),
    class_name="w-full flex flex-col rounded-md cursor-pointer",
)
```


## How to Fork an App

1. Browse or open an app you’d like to use as a starting point.
2. Click the **Fork** button in the app’s bottom right corner.
3. The AI Builder will create a **copy of the app** in your workspace.
4. You can now **edit, customize, and expand** your forked app independently of the original.

## What Happens When You Fork

- You get a **full copy** of the original app, including all pages, components, and configurations.
- The forked app is **completely separate**, so changes you make do not affect the original.
- You can **rename, deploy, or share** your forked app like any other app in your workspace.

## Common Use Cases

- **Start From an Example**
  Use a sample or shared app as a foundation to save time and learn best practices.

- **Experiment Safely**
  Try new ideas or features without risking changes to the original app.

- **Collaborate and Customize**
  Fork a teammate’s app to tailor it to your needs while keeping the original intact.


# Share App

The **Share** feature makes it easy to show your app to others without deploying it.
When you share, Reflex Build generates a unique link that points to the current version of your project in the builder.

```python exec
import reflex as rx
from reflex_image_zoom import image_zoom

def render_image():
    return rx.el.div(
        image_zoom(
            rx.image(
                src=rx.color_mode_cond(
                    "/ai_builder/app_lifecycle/share_light.webp",
                    "/ai_builder/app_lifecycle/share_dark.webp",
                ),
                class_name="p-2 rounded-md h-auto",
                border=f"0.81px solid {rx.color('slate', 5)}",
            ),
            class_name="rounded-md overflow-hidden",
        ),
        class_name="w-full flex flex-col rounded-md cursor-pointer",
    )
```

```python eval

rx.el.div(render_image())

```

## How to Share

1. In the AI Builder workspace, click the **Share** button (bottom-right corner).
2. A popup will appear with a **shareable link**.
3. Copy the link and send it to teammates, collaborators, or stakeholders.


## What Others See

- The link opens a **read-only view** of your app generation.
- Recipients can see the app preview but cannot make edits.
- This makes it safe to share work-in-progress versions for quick feedback.


## Common Use Cases

- **Get Feedback Quickly**
  Share a work-in-progress version with your team before deploying.

- **Demo Features**
  Send a link to showcase a new component, layout, or integration.

- **Collaboration**
  Share context with another developer before handing off to GitHub or download.


# Browser Storage

## rx.Cookie

Represents a state Var that is stored as a cookie in the browser. Currently only supports string values.

Parameters

- `name` : The name of the cookie on the client side.
- `path`: The cookie path. Use `/` to make the cookie accessible on all pages.
- `max_age` : Relative max age of the cookie in seconds from when the client receives it.
- `domain`: Domain for the cookie (e.g., `sub.domain.com` or `.allsubdomains.com`).
- `secure`: If the cookie is only accessible through HTTPS.
- `same_site`: Whether the cookie is sent with third-party requests. Can be one of (`True`, `False`, `None`, `lax`, `strict`).

```python
class CookieState(rx.State):
    c1: str = rx.Cookie()
    c2: str = rx.Cookie('c2 default')

    # cookies with custom settings
    c3: str = rx.Cookie(max_age=2)  # expires after 2 second
    c4: str = rx.Cookie(same_site='strict')
    c5: str = rx.Cookie(path='/foo/')  # only accessible on `/foo/`
    c6: str = rx.Cookie(name='c6-custom-name')
```

```md alert warning
# **The default value of a Cookie is never set in the browser!**

The Cookie value is only set when the Var is assigned. If you need to set a
default value, you can assign a value to the cookie in an `on_load` event
handler.
```

## Accessing Cookies

Cookies are accessed like any other Var in the state. If another state needs access
to the value of a cookie, the state should be a substate of the state that defines
the cookie. Alternatively the `get_state` API can be used to access the other state.

For rendering cookies in the frontend, import the state that defines the cookie and
reference it directly.

```md alert warning
# **Two separate states should _avoid_ defining `rx.Cookie` with the same name.**

Although it is technically possible, the cookie options may differ, leading to
unexpected results.

Additionally, updating the cookie value in one state will not automatically
update the value in the other state without a page refresh or navigation event.
```

## rx.remove_cookies

Remove a cookie from the client's browser.

Parameters:

- `key`: The name of cookie to remove.

```python
rx.button(
    'Remove cookie', on_click=rx.remove_cookie('key')
)
```

This event can also be returned from an event handler:

```python
class CookieState(rx.State):
    ...
    def logout(self):
        return rx.remove_cookie('auth_token')
```

## rx.LocalStorage

Represents a state Var that is stored in localStorage in the browser. Currently only supports string values.

Parameters

- `name`: The name of the storage key on the client side.
- `sync`: Boolean indicates if the state should be kept in sync across tabs of the same browser.

```python
class LocalStorageState(rx.State):
    # local storage with default settings
    l1: str = rx.LocalStorage()

    # local storage with custom settings
    l2: str = rx.LocalStorage("l2 default")
    l3: str = rx.LocalStorage(name="l3")

    # local storage that automatically updates in other states across tabs
    l4: str = rx.LocalStorage(sync=True)
```

### Syncing Vars

Because LocalStorage applies to the entire browser, all LocalStorage Vars are
automatically shared across tabs.

The `sync` parameter controls whether an update in one tab should be actively
propagated to other tabs without requiring a navigation or page refresh event.

## rx.remove_local_storage

Remove a local storage item from the client's browser.

Parameters

- `key`: The key to remove from local storage.

```python
rx.button(
    'Remove Local Storage',
    on_click=rx.remove_local_storage('key'),
)
```

This event can also be returned from an event handler:

```python
class LocalStorageState(rx.State):
    ...
    def logout(self):
        return rx.remove_local_storage('local_storage_state.l1')
```

## rx.clear_local_storage()

Clear all local storage items from the client's browser. This may affect other
apps running in the same domain or libraries within your app that use local
storage.

```python
rx.button(
    'Clear all Local Storage',
    on_click=rx.clear_local_storage(),
)
```

## rx.SessionStorage

Represents a state Var that is stored in sessionStorage in the browser. Similar to localStorage, but the data is cleared when the page session ends (when the browser/tab is closed). Currently only supports string values.

Parameters

- `name`: The name of the storage key on the client side.

```python
class SessionStorageState(rx.State):
    # session storage with default settings
    s1: str = rx.SessionStorage()

    # session storage with custom settings
    s2: str = rx.SessionStorage("s2 default")
    s3: str = rx.SessionStorage(name="s3")
```

### Session Persistence

SessionStorage data is cleared when the page session ends. A page session lasts as long as the browser is open and survives page refreshes and restores, but is cleared when the tab or browser is closed.

Unlike LocalStorage, SessionStorage is isolated to the tab/window in which it was created, so it's not shared with other tabs/windows of the same origin.

## rx.remove_session_storage

Remove a session storage item from the client's browser.

Parameters

- `key`: The key to remove from session storage.

```python
rx.button(
    'Remove Session Storage',
    on_click=rx.remove_session_storage('key'),
)
```

This event can also be returned from an event handler:

```python
class SessionStorageState(rx.State):
    ...
    def logout(self):
        return rx.remove_session_storage('session_storage_state.s1')
```

## rx.clear_session_storage()

Clear all session storage items from the client's browser. This may affect other
apps running in the same domain or libraries within your app that use session
storage.

```python
rx.button(
    'Clear all Session Storage',
    on_click=rx.clear_session_storage(),
)
```

# Serialization Strategies

If a non-trivial data structure should be stored in a `Cookie`, `LocalStorage`, or `SessionStorage` var it needs to be serialized before and after storing it. It is recommended to use a pydantic class for the data which provides simple serialization helpers and works recursively in complex object structures.

```python demo exec
import reflex as rx
import pydantic


class AppSettings(pydantic.BaseModel):
    theme: str = 'light'
    sidebar_visible: bool = True
    update_frequency: int = 60
    error_messages: list[str] = pydantic.Field(default_factory=list)


class ComplexLocalStorageState(rx.State):
    data_raw: str = rx.LocalStorage("{}")
    data: AppSettings = AppSettings()
    settings_open: bool = False

    @rx.event
    def save_settings(self):
        self.data_raw = self.data.model_dump_json()
        self.settings_open = False

    @rx.event
    def open_settings(self):
        self.data = AppSettings.model_validate_json(self.data_raw)
        self.settings_open = True

    @rx.event
    def set_field(self, field, value):
        setattr(self.data, field, value)


def app_settings():
    return rx.form.root(
        rx.foreach(
            ComplexLocalStorageState.data.error_messages,
            rx.text,
        ),
        rx.form.field(
            rx.flex(
                rx.form.label(
                    "Theme",
                    rx.input(
                        value=ComplexLocalStorageState.data.theme,
                        on_change=lambda v: ComplexLocalStorageState.set_field(
                            "theme", v
                        ),
                    ),
                ),
                rx.form.label(
                    "Sidebar Visible",
                    rx.switch(
                        checked=ComplexLocalStorageState.data.sidebar_visible,
                        on_change=lambda v: ComplexLocalStorageState.set_field(
                            "sidebar_visible",
                            v,
                        ),
                    ),
                ),
                rx.form.label(
                    "Update Frequency (seconds)",
                    rx.input(
                        value=ComplexLocalStorageState.data.update_frequency,
                        on_change=lambda v: ComplexLocalStorageState.set_field(
                            "update_frequency",
                            v,
                        ),
                    ),
                ),
                rx.dialog.close(rx.button("Save", type="submit")),
                gap=2,
                direction="column",
            )
        ),
        on_submit=lambda _: ComplexLocalStorageState.save_settings(),
    )

def app_settings_example():
    return rx.dialog.root(
        rx.dialog.trigger(
            rx.button("App Settings", on_click=ComplexLocalStorageState.open_settings),
        ),
        rx.dialog.content(
            rx.dialog.title("App Settings"),
            app_settings(),
        ),
    )
```

# Comparison of Storage Types

Here's a comparison of the different client-side storage options in Reflex:

| Feature | rx.Cookie | rx.LocalStorage | rx.SessionStorage |
|---------|-----------|----------------|------------------|
| Persistence | Until cookie expires | Until explicitly deleted | Until browser/tab is closed |
| Storage Limit | ~4KB | ~5MB | ~5MB |
| Sent with Requests | Yes | No | No |
| Accessibility | Server & Client | Client Only | Client Only |
| Expiration | Configurable | Never | End of session |
| Scope | Configurable (domain, path) | Origin (domain) | Tab/Window |
| Syncing Across Tabs | No | Yes (with sync=True) | No |
| Use Case | Authentication, Server-side state | User preferences, App state | Temporary session data |

# When to Use Each Storage Type

## Use rx.Cookie When:
- You need the data to be accessible on the server side (cookies are sent with HTTP requests)
- You're handling user authentication
- You need fine-grained control over expiration and scope
- You need to limit the data to specific paths in your app

## Use rx.LocalStorage When:
- You need to store larger amounts of data (up to ~5MB)
- You want the data to persist indefinitely (until explicitly deleted)
- You need to share data between different tabs/windows of your app
- You want to store user preferences that should be remembered across browser sessions

## Use rx.SessionStorage When:
- You need temporary data that should be cleared when the browser/tab is closed
- You want to isolate data to a specific tab/window
- You're storing sensitive information that shouldn't persist after the session ends
- You're implementing per-session features like form data, shopping carts, or multi-step processes
- You want to persist data for a state after Redis expiration (for server-side state that needs to survive longer than Redis TTL)


```python exec
import reflex as rx
from pcweb.pages.docs import advanced_onboarding
```

# Plugins

Reflex supports a plugin system that allows you to extend the framework's functionality during the compilation process. Plugins can add frontend dependencies, modify build configurations, generate static assets, and perform custom tasks before compilation.

## Configuring Plugins

Plugins are configured in your `rxconfig.py` file using the `plugins` parameter:

```python
import reflex as rx

config = rx.Config(
    app_name="my_app",
    plugins=[
        rx.plugins.SitemapPlugin(),
        rx.plugins.TailwindV4Plugin(),
    ],
)
```

## Built-in Plugins

Reflex comes with several built-in plugins that provide common functionality.

### SitemapPlugin

The `SitemapPlugin` automatically generates a sitemap.xml file for your application, which helps search engines discover and index your pages.

```python
import reflex as rx

config = rx.Config(
    app_name="my_app",
    plugins=[
        rx.plugins.SitemapPlugin(),
    ],
)
```

The sitemap plugin automatically includes all your app's routes. For dynamic routes or custom configuration, you can add sitemap metadata to individual pages:

```python
@rx.page(route="/blog/[slug]", context={"sitemap": {"changefreq": "weekly", "priority": 0.8}})
def blog_post():
    return rx.text("Blog post content")

@rx.page(route="/about", context={"sitemap": {"changefreq": "monthly", "priority": 0.5}})
def about():
    return rx.text("About page")
```

The sitemap configuration supports the following options:
- `loc`: Custom URL for the page (required for dynamic routes)
- `lastmod`: Last modification date (datetime object)
- `changefreq`: How frequently the page changes (`"always"`, `"hourly"`, `"daily"`, `"weekly"`, `"monthly"`, `"yearly"`, `"never"`)
- `priority`: Priority of this URL relative to other URLs (0.0 to 1.0)

### TailwindV4Plugin

The `TailwindV4Plugin` provides support for Tailwind CSS v4, which is the recommended version for new projects and includes performance improvements and new features.

```python
import reflex as rx

# Basic configuration
config = rx.Config(
    app_name="my_app",
    plugins=[
        rx.plugins.TailwindV4Plugin(),
    ],
)
```

You can customize the Tailwind configuration by passing a config dictionary:

```python
import reflex as rx

tailwind_config = {
    "theme": {
        "extend": {
            "colors": {
                "brand": {
                    "50": "#eff6ff",
                    "500": "#3b82f6",
                    "900": "#1e3a8a",
                }
            }
        }
    },
    "plugins": ["@tailwindcss/typography"],
}

config = rx.Config(
    app_name="my_app",
    plugins=[
        rx.plugins.TailwindV4Plugin(tailwind_config),
    ],
)
```

### TailwindV3Plugin

The `TailwindV3Plugin` integrates Tailwind CSS v3 into your Reflex application. While still supported, TailwindV4Plugin is recommended for new projects.

```python
import reflex as rx

# Basic configuration
config = rx.Config(
    app_name="my_app",
    plugins=[
        rx.plugins.TailwindV3Plugin(),
    ],
)
```

You can customize the Tailwind configuration by passing a config dictionary:

```python
import reflex as rx

tailwind_config = {
    "theme": {
        "extend": {
            "colors": {
                "primary": "#3b82f6",
                "secondary": "#64748b",
            }
        }
    },
    "plugins": ["@tailwindcss/typography", "@tailwindcss/forms"],
}

config = rx.Config(
    app_name="my_app",
    plugins=[
        rx.plugins.TailwindV3Plugin(tailwind_config),
    ],
)
```

## Plugin Management

### Default Plugins

Some plugins are enabled by default. Currently, the `SitemapPlugin` is enabled automatically. If you want to disable a default plugin, use the `disable_plugins` parameter:

```python
import reflex as rx

config = rx.Config(
    app_name="my_app",
    disable_plugins=["reflex.plugins.sitemap.SitemapPlugin"],
)
```

### Plugin Order

Plugins are executed in the order they appear in the `plugins` list. This can be important if plugins have dependencies on each other or modify the same files.

```python
import reflex as rx

config = rx.Config(
    app_name="my_app",
    plugins=[
        rx.plugins.TailwindV4Plugin(),  # Runs first
        rx.plugins.SitemapPlugin(),     # Runs second
    ],
)
```


## Plugin Architecture

All plugins inherit from the base `Plugin` class and can implement several lifecycle methods:

```python
class Plugin:
    def get_frontend_development_dependencies(self, **context) -> list[str]:
        """Get NPM packages required by the plugin for development."""
        return []
    
    def get_frontend_dependencies(self, **context) -> list[str]:
        """Get NPM packages required by the plugin."""
        return []
    
    def get_static_assets(self, **context) -> Sequence[tuple[Path, str | bytes]]:
        """Get static assets required by the plugin."""
        return []
    
    def get_stylesheet_paths(self, **context) -> Sequence[str]:
        """Get paths to stylesheets required by the plugin."""
        return []
    
    def pre_compile(self, **context) -> None:
        """Called before compilation to perform custom tasks."""
        pass
```

### Creating Custom Plugins

You can create custom plugins by inheriting from the base `Plugin` class:

```python
from reflex.plugins.base import Plugin
from pathlib import Path

class CustomPlugin(Plugin):
    def get_frontend_dependencies(self, **context):
        return ["my-custom-package@1.0.0"]
    
    def pre_compile(self, **context):
        # Custom logic before compilation
        print("Running custom plugin logic...")
        
        # Add a custom task
        context["add_save_task"](self.create_custom_file)
    
    def create_custom_file(self):
        return "public/custom.txt", "Custom content"
```

Then use it in your configuration:

```python
import reflex as rx
from my_plugins import CustomPlugin

config = rx.Config(
    app_name="my_app",
    plugins=[
        CustomPlugin(),
    ],
)
```


```python exec
import reflex as rx
```

# Special Events

Reflex includes a set of built-in special events that can be utilized as event triggers
or returned from event handlers in your applications. These events enhance interactivity and user experience.
Below are the special events available in Reflex, along with explanations of their functionality:

## rx.console_log

Perform a console.log in the browser's console.

```python demo
rx.button('Log', on_click=rx.console_log('Hello World!'))
```

When triggered, this event logs a specified message to the browser's developer console.
It's useful for debugging and monitoring the behavior of your application.

## rx.scroll_to

scroll to an element in the page

```python demo
rx.button(
    "Scroll to download button",
    on_click=rx.scroll_to("download button")

)
```

When this is triggered, it scrolls to an element passed by id as parameter. Click on button to scroll to download button (rx.download section) at the bottom of the page

## rx.redirect

Redirect the user to a new path within the application.

### Parameters

- `path`: The destination path or URL to which the user should be redirected.
- `external`: If set to True, the redirection will open in a new tab. Defaults to `False`.

```python demo
rx.vstack(
    rx.button("open in tab", on_click=rx.redirect("/docs/api-reference/special-events")),
    rx.button("open in new tab", on_click=rx.redirect('https://github.com/reflex-dev/reflex/', is_external=True))
)
```

When this event is triggered, it navigates the user to a different page or location within your Reflex application.
By default, the redirection occurs in the same tab. However, if you set the external parameter to True, the redirection
will open in a new tab or window, providing a seamless user experience.

This event can also be run from an event handler in State. It is necessary to `return` the `rx.redirect()`.

```python demo exec
class RedirectExampleState(rx.State):
    """The app state."""

    @rx.event
    def change_page(self):
        return rx.redirect('https://github.com/reflex-dev/reflex/', is_external=True)

def redirect_example():
    return rx.vstack(
        rx.button("Change page in State", on_click=RedirectExampleState.change_page),
    )
```

## rx.set_clipboard

Set the specified text content to the clipboard.

```python demo
rx.button('Copy "Hello World" to clipboard',on_click=rx.set_clipboard('Hello World'),)
```

This event allows you to copy a given text or content to the user's clipboard.
It's handy when you want to provide a "Copy to Clipboard" feature in your application,
allowing users to easily copy information to paste elsewhere.

## rx.set_value

Set the value of a specified reference element.

```python demo
rx.hstack(
    rx.input(id='input1'),
    rx.button(
        'Erase', on_click=rx.set_value('input1', '')
    ),
)
```

With this event, you can modify the value of a particular HTML element, typically an input field or another form element.

## rx.window_alert

Create a window alert in the browser.

```python demo
rx.button('Alert', on_click=rx.window_alert('Hello World!'))
```

## rx.download

Download a file at a given path.

Parameters:

- `url`: The URL of the file to be downloaded.
- `data`: The data to be downloaded. Should be `str` or `bytes`, `data:` URI, `PIL.Image`, or any state Var (to be converted to JSON).
- `filename`: The desired filename of the downloaded file.

```md alert
# `url` and `data` args are mutually exclusive, and at least one of them must be provided.
```

```python demo
rx.button("Download", on_click=rx.download(url="/reflex_banner.png", filename="different_name_logo.png"), id="download button")
```


# CLI

The `reflex` command line interface (CLI) is a tool for creating and managing Reflex apps.

To see a list of all available commands, run `reflex --help`.

```bash
$ reflex --help

Usage: reflex [OPTIONS] COMMAND [ARGS]...

  Reflex CLI to create, run, and deploy apps.

Options:
  --version  Show the version and exit.
  --help     Show this message and exit.

Commands:
  cloud      The Hosting CLI.
  component  CLI for creating custom components.
  db         Subcommands for managing the database schema.
  deploy     Deploy the app to the Reflex hosting service.
  export     Export the app to a zip file.
  init       Initialize a new Reflex app in the current directory.
  login      Authenticate with experimental Reflex hosting service.
  logout     Log out of access to Reflex hosting service.
  rename     Rename the app in the current directory.
  run        Run the app in the current directory.
  script     Subcommands for running helper scripts.
```

## Init

The `reflex init` command creates a new Reflex app in the current directory.
If an `rxconfig.py` file already exists already, it will re-initialize the app with the latest template.

```bash
$ reflex init --help
Usage: reflex init [OPTIONS]

  Initialize a new Reflex app in the current directory.

Options:
  --name APP_NAME                 The name of the app to initialize.
  --template [demo|sidebar|blank]
                                  The template to initialize the app with.
  --loglevel [debug|info|warning|error|critical]
                                  The log level to use.  [default:
                                  LogLevel.INFO]
  --help                          Show this message and exit.
```

## Run

The `reflex run` command runs the app in the current directory.

By default it runs your app in development mode.
This means that the app will automatically reload when you make changes to the code.
You can also run in production mode which will create an optimized build of your app.

You can configure the mode, as well as other options through flags.

```bash
$ reflex run --help
Usage: reflex run [OPTIONS]

  Run the app in the current directory.

Options:
  --env [dev|prod]                The environment to run the app in.
                                  [default: Env.DEV]
  --frontend-only                 Execute only frontend.
  --backend-only                  Execute only backend.
  --frontend-port TEXT            Specify a different frontend port.
                                  [default: 3000]
  --backend-port TEXT             Specify a different backend port.  [default:
                                  8000]
  --backend-host TEXT             Specify the backend host.  [default:
                                  0.0.0.0]
  --loglevel [debug|info|warning|error|critical]
                                  The log level to use.  [default:
                                  LogLevel.INFO]
  --help                          Show this message and exit.
```

## Export

You can export your app's frontend and backend to zip files using the `reflex export` command.

The frontend is a compiled NextJS app, which can be deployed to a static hosting service like Github Pages or Vercel.
However this is just a static build, so you will need to deploy the backend separately.
See the self-hosting guide for more information.

## Rename

The `reflex rename` command allows you to rename your Reflex app. This updates the app name in the configuration files.

```bash
$ reflex rename --help
Usage: reflex rename [OPTIONS] NEW_NAME

  Rename the app in the current directory.

Options:
  --loglevel [debug|default|info|warning|error|critical]
                                  The log level to use.
  --help                          Show this message and exit.
```

## Cloud

The `reflex cloud` command provides access to the Reflex Cloud hosting service. It includes subcommands for managing apps, projects, secrets, and more.

For detailed documentation on Reflex Cloud and deployment, see the [Cloud Quick Start Guide](https://reflex.dev/docs/hosting/deploy-quick-start/).

## Script

The `reflex script` command provides access to helper scripts for Reflex development.

```bash
$ reflex script --help
Usage: reflex script [OPTIONS] COMMAND [ARGS]...

  Subcommands for running helper scripts.

Options:
  --help  Show this message and exit.
```


```python exec
import asyncio
from typing import Any
import reflex as rx
from pcweb.pages.docs import wrapping_react
from pcweb.pages.docs import library
```

# Browser Javascript

Reflex compiles your frontend code, defined as python functions, into a Javascript web application
that runs in the user's browser. There are instances where you may need to supply custom javascript
code to interop with Web APIs, use certain third-party libraries, or wrap low-level functionality
that is not exposed via Reflex's Python API.

```md alert
# Avoid Custom Javascript

Custom Javascript code in your Reflex app presents a maintenance challenge, as it will be harder to debug and may be unstable across Reflex versions.

Prefer to use the Python API whenever possible and file an issue if you need additional functionality that is not currently provided.
```

## Executing Script

There are four ways to execute custom Javascript code into your Reflex app:

- `rx.script` - Injects the script via `next/script` for efficient loading of inline and external Javascript code. Described further in the [component library]({library.other.script.path}).
  - These components can be directly included in the body of a page, or they may
    be passed to `rx.App(head_components=[rx.script(...)])` to be included in
    the `<Head>` tag of all pages.
- `rx.call_script` - An event handler that evaluates arbitrary Javascript code,
  and optionally returns the result to another event handler.

These previous two methods can work in tandem to load external scripts and then
call functions defined within them in response to user events.

The following two methods are geared towards wrapping components and are
described with examples in the [Wrapping React]({wrapping_react.overview.path})
section.

- `_get_hooks` and `_get_custom_code` in an `rx.Component` subclass
- `Var.create` with `_var_is_local=False`

## Inline Scripts

The `rx.script` component is the recommended way to load inline Javascript for greater control over
frontend behavior.

The functions and variables in the script can be accessed from backend event
handlers or frontend event triggers via the `rx.call_script` interface.

```python demo exec
class SoundEffectState(rx.State):
    @rx.event(background=True)
    async def delayed_play(self):
        await asyncio.sleep(1)
        return rx.call_script("playFromStart(button_sfx)")


def sound_effect_demo():
    return rx.hstack(
        rx.script("""
            var button_sfx = new Audio("/vintage-button-sound-effect.mp3")
            function playFromStart (sfx) {sfx.load(); sfx.play()}"""),
        rx.button("Play Immediately", on_click=rx.call_script("playFromStart(button_sfx)")),
        rx.button("Play Later", on_click=SoundEffectState.delayed_play),
    )
```

## External Scripts

External scripts can be loaded either from the `assets` directory, or from CDN URL, and then controlled
via `rx.call_script`.

```python demo
rx.vstack(
    rx.script(
        src="https://cdn.jsdelivr.net/gh/scottschiller/snowstorm@snowstorm_20131208/snowstorm-min.js",
    ),
    rx.script("""
        window.addEventListener('load', function() {
            if (typeof snowStorm !== 'undefined') {
                snowStorm.autoStart = false;
                snowStorm.snowColor = '#111';
            }
        });
    """),
    rx.button("Start Duststorm", on_click=rx.call_script("snowStorm.start()")),
    rx.button("Toggle Duststorm", on_click=rx.call_script("snowStorm.toggleSnow()")),
)
```

## Accessing Client Side Values

The `rx.call_script` function accepts a `callback` parameter that expects an
Event Handler with one argument which will receive the result of evaluating the
Javascript code. This can be used to access client-side values such as the
`window.location` or current scroll location, or any previously defined value.

```python demo exec
class WindowState(rx.State):
    location: dict[str, str] = {}
    scroll_position: dict[str, int] = {}

    def update_location(self, location):
        self.location = location

    def update_scroll_position(self, scroll_position):
        self.scroll_position = {
            "x": scroll_position[0],
            "y": scroll_position[1],
        }

    @rx.event
    def get_client_values(self):
        return [
            rx.call_script(
                "window.location",
                callback=WindowState.update_location
            ),
            rx.call_script(
                "[window.scrollX, window.scrollY]",
                callback=WindowState.update_scroll_position,
            ),
        ]


def window_state_demo():
    return rx.vstack(
        rx.button("Update Values", on_click=WindowState.get_client_values),
        rx.text(f"Scroll Position: {WindowState.scroll_position.to_string()}"),
        rx.text("window.location:"),
        rx.text_area(value=WindowState.location.to_string(), is_read_only=True),
        on_mount=WindowState.get_client_values,
    )
```

```md alert
# Allowed Callback Values

The `callback` parameter may be an `EventHandler` with one argument, or a lambda with one argument that returns an `EventHandler`.
If the callback is None, then no event is triggered.
```

## Using React Hooks

To use React Hooks directly in a Reflex app, you must subclass `rx.Component`,
typically `rx.Fragment` is used when the hook functionality has no visual
element. The hook code is returned by the `add_hooks` method, which is expected
to return a `list[str]` containing Javascript code which will be inserted into the
page component (i.e the render function itself).

For supporting code that must be defined outside of the component render
function, use `_get_custom_code`.

The following example uses `useEffect` to register global hotkeys on the
`document` object, and then triggers an event when a specific key is pressed.

```python demo exec
import dataclasses

from reflex.utils import imports

@dataclasses.dataclass
class KeyEvent:
    """Interface of Javascript KeyboardEvent"""
    key: str = ""

def key_event_spec(ev: rx.Var[KeyEvent]) -> tuple[rx.Var[str]]:
    # Takes the event object and returns the key pressed to send to the state
    return (ev.key,)

class GlobalHotkeyState(rx.State):
    key: str = ""

    @rx.event
    def update_key(self, key):
        self.key = key


class GlobalHotkeyWatcher(rx.Fragment):
    """A component that listens for key events globally."""

    # The event handler that will be called
    on_key_down: rx.EventHandler[key_event_spec]

    def add_imports(self) -> imports.ImportDict:
        """Add the imports for the component."""
        return {
            "react": [imports.ImportVar(tag="useEffect")],
        }

    def add_hooks(self) -> list[str | rx.Var]:
        """Add the hooks for the component."""
        return [
            """
            useEffect(() => {
                const handle_key = %s;
                document.addEventListener("keydown", handle_key, false);
                return () => {
                    document.removeEventListener("keydown", handle_key, false);
                }
            })
            """
            % str(rx.Var.create(self.event_triggers["on_key_down"]))
        ]

def global_key_demo():
    return rx.vstack(
        GlobalHotkeyWatcher.create(
            keys=["a", "s", "d", "w"],
            on_key_down=lambda key: rx.cond(
                rx.Var.create(["a", "s", "d", "w"]).contains(key),
                GlobalHotkeyState.update_key(key),
                rx.console_log(key)
            )
        ),
        rx.text("Press a, s, d or w to trigger an event"),
        rx.heading(f"Last watched key pressed: {GlobalHotkeyState.key}"),
    )
```

This snippet can also be imported through pip: [reflex-global-hotkey](https://pypi.org/project/reflex-global-hotkey/).


```python exec
import reflex as rx
from pcweb import constants, styles
```

# Utility Functions

Reflex provides utility functions to help with common tasks in your applications.

## run_in_thread

The `run_in_thread` function allows you to run a **non-async** function in a separate thread, which is useful for preventing long-running operations from blocking the UI event queue.

```python
async def run_in_thread(func: Callable) -> Any
```

### Parameters

- `func`: The non-async function to run in a separate thread.

### Returns

- The return value of the function.

### Raises

- `ValueError`: If the function is an async function.

### Usage

```python demo exec id=run_in_thread_demo
import asyncio
import dataclasses
import time
import reflex as rx


def quick_blocking_function():
    time.sleep(0.5)
    return "Quick task completed successfully!"


def slow_blocking_function():
    time.sleep(3.0)
    return "This should never be returned due to timeout!"


@dataclasses.dataclass
class TaskInfo:
    result: str = "No result yet"
    status: str = "Idle"


class RunInThreadState(rx.State):
    tasks: list[TaskInfo] = []
    
    @rx.event(background=True)
    async def run_quick_task(self):
        """Run a quick task that completes within the timeout."""
        async with self:
            task_ix = len(self.tasks)
            self.tasks.append(TaskInfo(status="Running quick task..."))
            task_info = self.tasks[task_ix]
        
        try:
            result = await rx.run_in_thread(quick_blocking_function)
            async with self:
                task_info.result = result
                task_info.status = "Complete"
        except Exception as e:
            async with self:
                task_info.result = f"Error: {str(e)}"
                task_info.status = "Failed"
    
    @rx.event(background=True)
    async def run_slow_task(self):
        """Run a slow task that exceeds the timeout."""
        async with self:
            task_ix = len(self.tasks)
            self.tasks.append(TaskInfo(status="Running slow task..."))
            task_info = self.tasks[task_ix]
        
        try:
            # Run with a timeout of 1 second (not enough time)
            result = await asyncio.wait_for(
                rx.run_in_thread(slow_blocking_function),
                timeout=1.0,
            )
            async with self:
                task_info.result = result
                task_info.status = "Complete"
        except asyncio.TimeoutError:
            async with self:
                # Warning: even though we stopped waiting for the task,
                # it may still be running in thread
                task_info.result = "Task timed out after 1 second!"
                task_info.status = "Timeout"
        except Exception as e:
            async with self:
                task_info.result = f"Error: {str(e)}"
                task_info.status = "Failed"


def run_in_thread_example():
    return rx.vstack(
        rx.heading("run_in_thread Example", size="3"),
        rx.hstack(
            rx.button(
                "Run Quick Task",
                on_click=RunInThreadState.run_quick_task,
                color_scheme="green",
            ),
            rx.button(
                "Run Slow Task (exceeds timeout)",
                on_click=RunInThreadState.run_slow_task,
                color_scheme="red",
            ),
        ),
        rx.vstack(
            rx.foreach(
                RunInThreadState.tasks.reverse()[:10],
                lambda task: rx.hstack(
                    rx.text(task.status),
                    rx.spacer(),
                    rx.text(task.result),
                ),
            ),
            align="start",
            width="100%",
        ),
        width="100%",
        align_items="start",
        spacing="4",
    )
```

### When to Use run_in_thread

Use `run_in_thread` when you need to:

1. Execute CPU-bound operations that would otherwise block the event loop
2. Call synchronous libraries that don't have async equivalents
3. Prevent long-running operations from blocking UI responsiveness

### Example: Processing a Large File

```python
import reflex as rx
import time

class FileProcessingState(rx.State):
    progress: str = "Ready"
    
    @rx.event(background=True)
    async def process_large_file(self):
        async with self:
            self.progress = "Processing file..."
        
        def process_file():
            # Simulate processing a large file
            time.sleep(5)
            return "File processed successfully!"
        
        # Save the result to a local variable to avoid blocking the event loop.
        result = await rx.run_in_thread(process_file)
        async with self:
            # Then assign the local result to the state while holding the lock.
            self.progress = result
```


```python exec
from datetime import datetime

import reflex as rx

from pcweb.templates.docpage import docdemo, h1_comp, text_comp, docpage
from pcweb.pages.docs import events

SYNTHETIC_EVENTS = [
    {
        "name": "on_focus",
        "description": "The on_focus event handler is called when the element (or some element inside of it) receives focus. For example, it’s called when the user clicks on a text input.",
        "state": """class FocusState(rx.State):
    text = "Change Me!"

    @rx.event
    def change_text(self, text):
        if self.text == "Change Me!":
            self.text = "Changed!"
        else:
            self.text = "Change Me!"
""",
        "example": """rx.input(value=FocusState.text, on_focus=FocusState.change_text)""",
    },
    {
        "name": "on_blur",
        "description": "The on_blur event handler is called when focus has left the element (or left some element inside of it). For example, it’s called when the user clicks outside of a focused text input.",
        "state": """class BlurState(rx.State):
    text = "Change Me!"

    @rx.event
    def change_text(self, text):
        if self.text == "Change Me!":
            self.text = "Changed!"
        else:
            self.text = "Change Me!"
""",
        "example": """rx.input(value=BlurState.text, on_blur=BlurState.change_text)""",
    },
    {
        "name": "on_change",
        "description": "The on_change event handler is called when the value of an element has changed. For example, it’s called when the user types into a text input each keystroke triggers the on change.",
        "state": """class ChangeState(rx.State):
    checked: bool = False

""",
        "example": """rx.switch(on_change=ChangeState.set_checked)""",
    },
    {
        "name": "on_click",
        "description": "The on_click event handler is called when the user clicks on an element. For example, it’s called when the user clicks on a button.",
        "state": """class ClickState(rx.State):
    text = "Change Me!"

    @rx.event
    def change_text(self):
        if self.text == "Change Me!":
            self.text = "Changed!"
        else:
            self.text = "Change Me!"
""",
        "example": """rx.button(ClickState.text, on_click=ClickState.change_text)""",
    },
    {
        "name": "on_context_menu",
        "description": "The on_context_menu event handler is called when the user right-clicks on an element. For example, it’s called when the user right-clicks on a button.",
        "state": """class ContextState(rx.State):
    text = "Change Me!"

    @rx.event
    def change_text(self):
        if self.text == "Change Me!":
            self.text = "Changed!"
        else:
            self.text = "Change Me!"
""",
        "example": """rx.button(ContextState.text, on_context_menu=ContextState.change_text)""",
    },
    {
        "name": "on_double_click",
        "description": "The on_double_click event handler is called when the user double-clicks on an element. For example, it’s called when the user double-clicks on a button.",
        "state": """class DoubleClickState(rx.State):
    text = "Change Me!"

    @rx.event
    def change_text(self):
        if self.text == "Change Me!":
            self.text = "Changed!"
        else:
            self.text = "Change Me!"
""",
        "example": """rx.button(DoubleClickState.text, on_double_click=DoubleClickState.change_text)""",
    },
    {
        "name": "on_mount",
        "description": "The on_mount event handler is called after the component is rendered on the page. It is similar to a page on_load event, although it does not necessarily fire when navigating between pages. This event is particularly useful for initializing data, making API calls, or setting up component-specific state when a component first appears.",
        "state": """class MountState(rx.State):
    events: list[str] = []
    data: list[dict] = []
    loading: bool = False

    @rx.event
    def on_mount(self):
        self.events = self.events[-4:] + ["on_mount @ " + str(datetime.now())]
        
    @rx.event
    async def load_data(self):
        # Common pattern: Set loading state, yield to update UI, then fetch data
        self.loading = True
        yield
        # Simulate API call
        import asyncio
        await asyncio.sleep(1)
        self.data = [dict(id=1, name="Item 1"), dict(id=2, name="Item 2")]
        self.loading = False
""",
        "example": """rx.vstack(
    rx.heading("Component Lifecycle Demo"),
    rx.foreach(MountState.events, rx.text),
    rx.cond(
        MountState.loading,
        rx.spinner(),
        rx.foreach(
            MountState.data,
            lambda item: rx.text(f"ID: {item['id']} - {item['name']}")
        )
    ),
    on_mount=MountState.on_mount,
)""",
    },
    {
        "name": "on_unmount",
        "description": "The on_unmount event handler is called after removing the component from the page. However, on_unmount will only be called for internal navigation, not when following external links or refreshing the page. This event is useful for cleaning up resources, saving state, or performing cleanup operations before a component is removed from the DOM.",
        "state": """class UnmountState(rx.State):
    events: list[str] = []
    resource_id: str = "resource-12345"
    status: str = "Resource active"

    @rx.event
    def on_unmount(self):
        self.events = self.events[-4:] + ["on_unmount @ " + str(datetime.now())]
        # Common pattern: Clean up resources when component is removed
        self.status = f"Resource {self.resource_id} cleaned up"
        
    @rx.event
    def initialize_resource(self):
        self.status = f"Resource {self.resource_id} initialized"
""",
        "example": """rx.vstack(
    rx.heading("Unmount Demo"),
    rx.foreach(UnmountState.events, rx.text),
    rx.text(UnmountState.status),
    rx.link(
        rx.button("Navigate Away (Triggers Unmount)"),
        href="/docs",
    ),
    on_mount=UnmountState.initialize_resource,
    on_unmount=UnmountState.on_unmount,
)""",
    },
    {
        "name": "on_mouse_up",
        "description": "The on_mouse_up event handler is called when the user releases a mouse button on an element. For example, it’s called when the user releases the left mouse button on a button.",
        "state": """class MouseUpState(rx.State):
    text = "Change Me!"

    @rx.event
    def change_text(self):
        if self.text == "Change Me!":
            self.text = "Changed!"
        else:
            self.text = "Change Me!"
""",
        "example": """rx.button(MouseUpState.text, on_mouse_up=MouseUpState.change_text)""",
    },
    {
        "name": "on_mouse_down",
        "description": "The on_mouse_down event handler is called when the user presses a mouse button on an element. For example, it’s called when the user presses the left mouse button on a button.",
        "state": """class MouseDown(rx.State):
    text = "Change Me!"

    @rx.event
    def change_text(self):
        if self.text == "Change Me!":
            self.text = "Changed!"
        else:
            self.text = "Change Me!"
""",
        "example": """rx.button(MouseDown.text, on_mouse_down=MouseDown.change_text)""",
    },
    {
        "name": "on_mouse_enter",
        "description": "The on_mouse_enter event handler is called when the user’s mouse enters an element. For example, it’s called when the user’s mouse enters a button.",
        "state": """class MouseEnter(rx.State):
    text = "Change Me!"

    @rx.event
    def change_text(self):
        if self.text == "Change Me!":
            self.text = "Changed!"
        else:
            self.text = "Change Me!"
""",
        "example": """rx.button(MouseEnter.text, on_mouse_enter=MouseEnter.change_text)""",
    },
    {
        "name": "on_mouse_leave",
        "description": "The on_mouse_leave event handler is called when the user’s mouse leaves an element. For example, it’s called when the user’s mouse leaves a button.",
        "state": """class MouseLeave(rx.State):
    text = "Change Me!"

    @rx.event
    def change_text(self):
        if self.text == "Change Me!":
            self.text = "Changed!"
        else:
            self.text = "Change Me!"
""",
        "example": """rx.button(MouseLeave.text, on_mouse_leave=MouseLeave.change_text)""",
    },
    {
        "name": "on_mouse_move",
        "description": "The on_mouse_move event handler is called when the user moves the mouse over an element. For example, it’s called when the user moves the mouse over a button.",
        "state": """class MouseMove(rx.State):
    text = "Change Me!"

    @rx.event
    def change_text(self):
        if self.text == "Change Me!":
            self.text = "Changed!"
        else:
            self.text = "Change Me!"
""",
        "example": """rx.button(MouseMove.text, on_mouse_move=MouseMove.change_text)""",
    },
    {
        "name": "on_mouse_out",
        "description": "The on_mouse_out event handler is called when the user’s mouse leaves an element. For example, it’s called when the user’s mouse leaves a button.",
        "state": """class MouseOut(rx.State):
    text = "Change Me!"

    @rx.event
    def change_text(self):
        if self.text == "Change Me!":
            self.text = "Changed!"
        else:
            self.text = "Change Me!"
""",
        "example": """rx.button(MouseOut.text, on_mouse_out=MouseOut.change_text)""",
    },
    {
        "name": "on_mouse_over",
        "description": "The on_mouse_over event handler is called when the user’s mouse enters an element. For example, it’s called when the user’s mouse enters a button.",
        "state": """class MouseOver(rx.State):
    text = "Change Me!"

    @rx.event
    def change_text(self):
        if self.text == "Change Me!":
            self.text = "Changed!"
        else:
            self.text = "Change Me!"
""",
        "example": """rx.button(MouseOver.text, on_mouse_over=MouseOver.change_text)""",
    },
    {
        "name": "on_scroll",
        "description": "The on_scroll event handler is called when the user scrolls the page. For example, it’s called when the user scrolls the page down.",
        "state": """class ScrollState(rx.State):
    text = "Change Me!"

    @rx.event
    def change_text(self):
        if self.text == "Change Me!":
            self.text = "Changed!"
        else:
            self.text = "Change Me!"
""",
        "example": """rx.vstack(
            rx.text("Scroll to make the text below change."),
            rx.text(ScrollState.text),
            rx.text("Scroll to make the text above change."),
            on_scroll=ScrollState.change_text,
            overflow = "auto",
            height = "3em",
            width = "100%",
        )""",
    },
]
for i in SYNTHETIC_EVENTS:
    exec(i["state"])

def component_grid():
    events = []
    for event in SYNTHETIC_EVENTS:
        events.append(
            rx.vstack(
                h1_comp(text=event["name"]),
                text_comp(text=event["description"]),
                docdemo(
                    event["example"], state=event["state"], comp=eval(event["example"])
                ),
                align_items="left",
            )
        )

    return rx.box(*events)
```

# Event Triggers

Components can modify the state based on user events such as clicking a button or entering text in a field.
These events are triggered by event triggers.

Event triggers are component specific and are listed in the documentation for each component.

## Component Lifecycle Events

Reflex components have lifecycle events like `on_mount` and `on_unmount` that allow you to execute code at specific points in a component's existence. These events are crucial for initializing data, cleaning up resources, and creating dynamic user interfaces.

### When Lifecycle Events Are Activated

- **on_mount**: This event is triggered immediately after a component is rendered and attached to the DOM. It fires:
  - When a page containing the component is first loaded
  - When a component is conditionally rendered (appears after being hidden)
  - When navigating to a page containing the component using internal navigation
  - It does NOT fire when the page is refreshed or when following external links

- **on_unmount**: This event is triggered just before a component is removed from the DOM. It fires:
  - When navigating away from a page containing the component using internal navigation
  - When a component is conditionally removed from the DOM (e.g., via a condition that hides it)
  - It does NOT fire when refreshing the page, closing the browser tab, or following external links

## Page Load Events

In addition to component lifecycle events, Reflex also provides page-level events like `on_load` that are triggered when a page loads. The `on_load` event is useful for:

- Fetching data when a page first loads
- Checking authentication status
- Initializing page-specific state
- Setting default values for cookies or browser storage

You can specify an event handler to run when the page loads using the `on_load` parameter in the `@rx.page` decorator or `app.add_page()` method:

```python
class State(rx.State):
    data: dict = dict()

    @rx.event
    def get_data(self):
        # Fetch data when the page loads
        self.data = fetch_data()

@rx.page(on_load=State.get_data)
def index():
    return rx.text('Data loaded on page load')
```

This is particularly useful for authentication checks:

```python
class State(rx.State):
    authenticated: bool = False

    @rx.event
    def check_auth(self):
        # Check if user is authenticated
        self.authenticated = check_auth()
        if not self.authenticated:
            return rx.redirect('/login')

@rx.page(on_load=State.check_auth)
def protected_page():
    return rx.text('Protected content')
```

For more details on page load events, see the [page load events documentation]({events.page_load_events.path}).

# Event Reference

```python eval
rx.box(
    rx.divider(),
    component_grid(),
)
```


# Reflex's Var System

## Motivation

Reflex supports some basic operations in state variables on the frontend.
Reflex automatically converts variable operations from Python into a JavaScript equivalent.

Here's an example of a Reflex conditional in Python that returns "Pass" if the threshold is equal to or greater than 50 and "Fail" otherwise:

```py
rx.cond(
    State.threshold >= 50,
    "Pass",
    "Fail",
)
```

 The conditional to roughly the following in Javascript:

```js
state.threshold >= 50 ? "Pass" : "Fail";
```

## Overview

Simply put, a `Var` in Reflex represents a Javascript expression.
If the type is known, it can be any of the following:

- `NumberVar` represents an expression that evaluates to a Javascript `number`. `NumberVar` can support both integers and floating point values
- `BooleanVar` represents a boolean expression. For example: `false`, `3 > 2`.
- `StringVar` represents an expression that evaluates to a string. For example: `'hello'`, `(2).toString()`.
- `ArrayVar` represents an expression that evaluates to an array object. For example: `[1, 2, 3]`, `'words'.split()`.
- `ObjectVar` represents an expression that evaluates to an object. For example: `\{a: 2, b: 3}`, `\{deeply: \{nested: \{value: false}}}`.
- `NoneVar` represent null values. These can be either `undefined` or `null`.

## Creating Vars

State fields are converted to `Var` by default. Additionally, you can create a `Var` from Python values using `rx.Var.create()`:

```py
rx.Var.create(4) # NumberVar
rx.Var.create("hello") # StringVar
rx.Var.create([1, 2, 3]) # ArrayVar
```

If you want to explicitly create a `Var` from a raw Javascript string, you can instantiate `rx.Var` directly:

```py
rx.Var("2", _var_type=int).guess_type() # NumberVar
```

In the example above, `.guess_type()` will attempt to downcast from a generic `Var` type into `NumberVar`.
For this example, calling the function `.to(int)` can also be used in place of `.guess_type()`.

## Operations

The `Var` system also supports some other basic operations.
For example, `NumberVar` supports basic arithmetic operations like `+` and `-`, as in Python.
It also supports comparisons that return a `BooleanVar`.

Custom `Var` operations can also be defined:

```py
from reflex.vars import var_operation, var_operation_return, ArrayVar, NumberVar

@var_operation
def multiply_array_values(a: ArrayVar):
    return var_operation_return(
        js_expression=f"\{a}.reduce((p, c) => p * c, 1)",
        var_type=int,
    )

def factorial(value: NumberVar):
    return rx.cond(
        value <= 1,
        1,
        multiply_array_values(rx.Var.range(1, value+1))
    )
```

Use `js_expression` to pass explicit JavaScript expressions; in the `multiply_array_values` example, we pass in a JavaScript expression that calculates the product of all elements in an array called `a` by using the reduce method to multiply each element with the accumulated result, starting from an initial value of 1.
Later, we leverage `rx.cond` in the' factorial' function, we instantiate an array using the `range` function, and pass this array to `multiply_array_values`.


```python exec
import reflex as rx
```

# API Transformer

In addition to your frontend app, Reflex uses a FastAPI backend to serve your app. The API transformer feature allows you to transform or extend the ASGI app that serves your Reflex application.

## Overview

The API transformer provides a way to:

1. Integrate existing FastAPI or Starlette applications with your Reflex app
2. Apply middleware or transformations to the ASGI app
3. Extend your Reflex app with additional API endpoints

This is useful for creating a backend API that can be used for purposes beyond your Reflex app, or for integrating Reflex with existing backend services.

## Using API Transformer

You can set the `api_transformer` parameter when initializing your Reflex app:

```python
import reflex as rx
from fastapi import FastAPI, Depends
from fastapi.security import OAuth2PasswordBearer

# Create a FastAPI app
fastapi_app = FastAPI(title="My API")

# Add routes to the FastAPI app
@fastapi_app.get("/api/items")
async def get_items():
    return dict(items=["Item1", "Item2", "Item3"])

# Create a Reflex app with the FastAPI app as the API transformer
app = rx.App(api_transformer=fastapi_app)
```

## Types of API Transformers

The `api_transformer` parameter can accept:

1. A Starlette or FastAPI instance
2. A callable that takes an ASGIApp and returns an ASGIApp
3. A sequence of the above

### Using a FastAPI or Starlette Instance

When you provide a FastAPI or Starlette instance as the API transformer, Reflex will mount its internal API to your app, allowing you to define additional routes:

```python
import reflex as rx
from fastapi import FastAPI, Depends
from fastapi.security import OAuth2PasswordBearer

# Create a FastAPI app with authentication
fastapi_app = FastAPI(title="Secure API")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

# Add a protected route
@fastapi_app.get("/api/protected")
async def protected_route(token: str = Depends(oauth2_scheme)):
    return dict(message="This is a protected endpoint")

# Create a token endpoint
@fastapi_app.post("/token")
async def login(username: str, password: str):
    # In a real app, you would validate credentials
    if username == "user" and password == "password":
        return dict(access_token="example_token", token_type="bearer")
    return dict(error="Invalid credentials")

# Create a Reflex app with the FastAPI app as the API transformer
app = rx.App(api_transformer=fastapi_app)
```

### Using a Callable Transformer

You can also provide a callable that transforms the ASGI app:

```python
import reflex as rx
from starlette.middleware.cors import CORSMiddleware

# Create a transformer function that returns a transformed ASGI app
def add_cors_middleware(app):
    # Wrap the app with CORS middleware and return the wrapped app
    return CORSMiddleware(
        app=app,
        allow_origins=["https://example.com"],
        allow_methods=["*"],
        allow_headers=["*"],
    )

# Create a Reflex app with the transformer
app = rx.App(api_transformer=add_cors_middleware)
```

### Using Multiple Transformers

You can apply multiple transformers by providing a sequence:

```python
import reflex as rx
from fastapi import FastAPI
from starlette.middleware import Middleware
from starlette.middleware.cors import CORSMiddleware

# Create a FastAPI app
fastapi_app = FastAPI(title="My API")

# Add routes to the FastAPI app
@fastapi_app.get("/api/items")
async def get_items():
    return dict(items=["Item1", "Item2", "Item3"])

# Create a transformer function
def add_logging_middleware(app):
    # This is a simple example middleware that logs requests
    async def middleware(scope, receive, send):
        # Log the request path
        path = scope["path"]
        print("Request:", path)
        await app(scope, receive, send)
    return middleware

# Create a Reflex app with multiple transformers
app = rx.App(api_transformer=[fastapi_app, add_logging_middleware])
```

## Reserved Routes

Some routes on the backend are reserved for the runtime of Reflex, and should not be overridden unless you know what you are doing.

### Ping

`localhost:8000/ping/`: You can use this route to check the health of the backend.

The expected return is `"pong"`.

### Event

`localhost:8000/_event`: the frontend will use this route to notify the backend that an event occurred.

```md alert error
# Overriding this route will break the event communication
```

### Upload

`localhost:8000/_upload`: This route is used for the upload of file when using `rx.upload()`.
